<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aviation Calculator - minimatool2025</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1300px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.08); }
        h1 { text-align: center; color: #333; margin-bottom: 30px; }
        .top-inputs { display: flex; gap: 20px; margin-bottom: 15px; align-items: center; flex-wrap: wrap; }
        .input-group { display: flex; flex-direction: column; gap: 5px; }
        .input-group label { font-weight: bold; color: #555; }
        .input-group input, .input-group select { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 120px; }
        .procedure-group { display: flex; align-items: center; gap: 10px; }
        .noncdfa-sub-group { margin-left: 12px; display: flex; gap: 10px;}
        .proc-checkbox-group { margin: 16px 0 10px 0; display: flex; flex-wrap: wrap; gap: 14px; }
        .calculators { display: flex; gap: 20px; margin-top: 20px; flex-wrap: wrap; }
        .calculator { flex: 1 1 350px; border: 2px solid #ddd; border-radius: 8px; padding: 15px; min-width: 340px; margin-bottom: 15px; }
        .calculator h3 { text-align: center; margin-bottom: 15px; color: #333; background: #f8f8f8; padding: 10px; border-radius: 4px; }
        .cat-row { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px; background: #fafafa; border-radius: 4px; }
        .cat-label { font-weight: bold; width: 55px; color: #555; }
        .cat-row input { width: 75px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
        .result { margin-left: 12px; font-weight: bold; color: #0066cc; font-size: 0.96em;}
        .calculate-btn { background: #007bff; color: white; padding: 12px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 24px auto; display: block; }
        .calculate-btn:hover { background: #0056b3; }
        #summaryResults { border-top:1px solid #ccc; padding-top:20px; margin-top:26px;}
        #summaryResults h2 { text-align:center;margin-bottom:8px;}
        #summaryResults h3 { margin-bottom:0;}
        .footer { text-align: center; margin-top: 26px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 14px; }
        /* Conversion Control */
        .conversion-control { 
            margin-bottom: 15px; 
            padding: 10px; 
            border: 1px solid #cceeff; 
            background: #e6f7ff; 
            border-radius: 6px; 
            display: flex; 
            align-items: center;
        }
        .conversion-control label {
            font-weight: bold;
            color: #0056b3;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .conversion-control input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        /* State Indicators Styles */
        .state-indicator {
          display: inline-block;
          min-width: 90px;
          font-weight: bold;
          text-align: center;
          padding: 7px 18px;
          border-radius: 7px;
          margin-right: 12px;
          font-size: 16px;
        }
        .state-standard {
          background: #e2fbe0;
          color: #208c2c;
          border: 2px solid #30ba4c;
        }
        .state-state {
          background: #ffd6d6;
          color: #be2222;
          border: 2px solid #da3131;
        }
        
        /* New warning style for Circling check */
        .raise-circling-note {
            display: block;
            margin-top: 4px;
            font-size: 0.85em;
            color: #d9534f; /* reddish color */
            font-weight: normal;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Minima Calculator (Aviation) </h1>
        <div class="top-inputs">
            <div class="input-group">
                <label>AD Elev (ft)</label>
                <input type="number" id="adElev" placeholder="0">
            </div>
            <div class="input-group">
                <label>THR Elev (ft)</label>
                <input type="number" id="thrElev" placeholder="0">
            </div>
            <div class="input-group">
                <label>ALS</label>
                <select id="lightType">
                    <option value="FALS">FALS</option>
                    <option value="IALS">IALS</option>
                    <option value="BALS">BALS</option>
                    <option value="NALS">NALS</option>
                </select>
            </div>
            <div class="procedure-group">
                <label>Procedure:</label>
                <input type="radio" name="procedure" value="CDFA" id="cdfa" checked>
                <label for="cdfa">CDFA</label>
                <input type="radio" name="procedure" value="Non-CDFA" id="noncdfa">
                <label for="noncdfa">NFC</label>
                <div id="noncdfaSubGroup" class="noncdfa-sub-group" style="display:none;">
                    <label><input type="checkbox" id="noncdfa_ab"> CAT A/B only</label>
                    <label><input type="checkbox" id="noncdfa_cd"> CAT C/D only</label>
                </div>
            </div>
        </div>

        <!-- NEW CONVERSION CONTROL CHECKBOX -->
        <div class="conversion-control">
            <label for="meterToFeetConversion">
                <input type="checkbox" id="meterToFeetConversion">
                Apply Meter to Feet Conversion Rule (DA, DH, MDA, MDH inputs interpreted as Meters)
            </label>
        </div>

        <div class="proc-checkbox-group" id="procedureCheckboxes"></div>
        <div class="calculators" id="calculatorsArea"></div>
        <button class="calculate-btn" onclick="calculate()">Calculate All</button>
        <button class="calculate-btn" type="button" onclick="clearAllInputs()">Clear All</button>
        <div id="summaryResults"></div>
       
        <!-- NEW: VISIBLE LICENSE SECTION (UPDATED) -->
        <div class="license-footer">
            <p>
                <b>Developer:</b> Vishal Kumar Basson | 
                <b>License:</b> GNU GPLv3 | 
                <b>Source:</b> Open Source Project
            </p>
        
        </div>
    </div>

    <!-- ============ Fixed Top-Right Zoom Controls ============ -->
    <div id="page-zoom-controls" style="
      position: fixed;
      top: 18px; 
      right: 24px; 
      z-index: 2000;
      display: flex; 
      gap: 10px; 
      align-items:center;
      background: rgba(245,245,245,0.96); 
      border-radius:8px;
      padding: 8px 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    ">
      <button type="button" onclick="zoomPage('+')" title="Zoom in" style="font-size:18px;">+</button>
      <button type="button" onclick="zoomPage('-')" title="Zoom out" style="font-size:18px;">-</button>
      <span id="zoom-indicator" style="margin-left:8px;font-size:14px; color:#444;"></span>
    </div>

    <script>
        // === Define Procedures ===
        const PRECISION_PROC = [
            { code: 'cat1', name: 'CAT 1' }, { code: 'rnp', name: 'RNP' }, { code: 'gls', name: 'GLS' },
            { code: 'par', name: 'PAR' }, { code: 'lpv', name: 'LPV' }, { code: 'lnavvnav', name: 'LNAV/VNAV' }
        ];
        const NONPRECISION_PROC_250 = [
            { code: 'loc', name: 'LOC' }, { code: 'locdme', name: 'LOC+DME' }, { code: 'vordme', name: 'VOR+DME' },
            { code: 'lnav', name: 'LNAV' }, { code: 'sra', name: 'SRA' }, { code: 'lda', name: 'LDA' }
        ];
        const NONPRECISION_PROC_300 = [
            { code: 'vor', name: 'VOR' }, { code: 'ndbdme', name: 'NDB+DME' }
        ];
        const NONPRECISION_PROC_350 = [{ code: 'ndb', name: 'NDB' }];
        const CIRCLING_PROC = [{ code: 'circling', name: 'Circling' }];
        const CATS = ['A','B','C','D'];

        // Fill in all RVR ranges from your full table here!
        const RVR_TABLE_RANGES = [
            {low: 200, high: 210, FALS: 550, IALS: 750, BALS: 1000, NALS: 1200},
            {low: 211, high: 220, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
            {low: 221, high: 230, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
            {low: 231, high: 240, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
            {low: 241, high: 250, FALS: 550, IALS: 800, BALS: 1000, NALS: 1300},
            {low: 251, high: 260, FALS: 600, IALS: 800, BALS: 1100, NALS: 1300},
            {low: 261, high: 280, FALS: 600, IALS: 900, BALS: 1100, NALS: 1300},
            {low: 281, high: 300, FALS: 650, IALS: 900, BALS: 1200, NALS: 1400},
            {low: 301, high: 320, FALS: 700, IALS: 1000, BALS: 1200, NALS: 1400},
            {low: 321, high: 340, FALS: 800, IALS: 1100, BALS: 1300, NALS: 1500},
            {low: 341, high: 360, FALS: 900, IALS: 1200, BALS: 1400, NALS: 1600},
            {low: 361, high: 380, FALS: 1000, IALS: 1300, BALS: 1500, NALS: 1700},
            {low: 381, high: 400, FALS: 1100, IALS: 1400, BALS: 1600, NALS: 1800},
            {low: 401, high: 420, FALS: 1200, IALS: 1500, BALS: 1700, NALS: 1900},
            {low: 421, high: 440, FALS: 1300, IALS: 1600, BALS: 1800, NALS: 2000},
            {low: 441, high: 460, FALS: 1400, IALS: 1700, BALS: 1900, NALS: 2100},
            {low: 461, high: 480, FALS: 1500, IALS: 1800, BALS: 2000, NALS: 2200},
            {low: 481, high: 500, FALS: 1500, IALS: 1800, BALS: 2100, NALS: 2300},
            {low: 501, high: 520, FALS: 1600, IALS: 1900, BALS: 2100, NALS: 2400},
            {low: 521, high: 540, FALS: 1700, IALS: 2000, BALS: 2200, NALS: 2400},
            {low: 541, high: 560, FALS: 1800, IALS: 2100, BALS: 2300, NALS: 2500},
            {low: 561, high: 580, FALS: 1900, IALS: 2200, BALS: 2400, NALS: 2600},
            {low: 581, high: 600, FALS: 2000, IALS: 2300, BALS: 2500, NALS: 2700},
            {low: 601, high: 620, FALS: 2100, IALS: 2400, BALS: 2600, NALS: 2800},
            {low: 621, high: 640, FALS: 2200, IALS: 2500, BALS: 2700, NALS: 2900},
            {low: 641, high: 660, FALS: 2300, IALS: 2600, BALS: 2800, NALS: 3000},
            {low: 661, high: 680, FALS: 2400, IALS: 2700, BALS: 2900, NALS: 3100},
            {low: 681, high: 700, FALS: 2500, IALS: 2800, BALS: 3000, NALS: 3200},
            {low: 701, high: 720, FALS: 2600, IALS: 2900, BALS: 3100, NALS: 3300},
            {low: 721, high: 740, FALS: 2700, IALS: 3000, BALS: 3200, NALS: 3400},
            {low: 741, high: 760, FALS: 2700, IALS: 3000, BALS: 3300, NALS: 3500},
            {low: 761, high: 800, FALS: 2900, IALS: 3200, BALS: 3400, NALS: 3600},
            {low: 801, high: 850, FALS: 3100, IALS: 3400, BALS: 3600, NALS: 3800},
            {low: 851, high: 900, FALS: 3300, IALS: 3600, BALS: 3800, NALS: 4000},
            {low: 901, high: 950, FALS: 3600, IALS: 3900, BALS: 4100, NALS: 4300},
            {low: 951, high: 1000, FALS: 3800, IALS: 4100, BALS: 4300, NALS: 4500},
            {low: 1001, high: 1100, FALS: 4100, IALS: 4400, BALS: 4600, NALS: 4900},
            {low: 1101, high: 1200, FALS: 4600, IALS: 4900, BALS: 5000, NALS: 5000},
            {low: 1201, high: 9999, FALS: 5000, IALS: 5000, BALS: 5000, NALS: 5000}
        ];
        function getRVRFromTable(dh, lightType) {
            for (let row of RVR_TABLE_RANGES) {
                if (dh >= row.low && dh <= row.high) return row[lightType];
            }
            return RVR_TABLE_RANGES[RVR_TABLE_RANGES.length-1][lightType];
        }
        function roundUpTo10(x) { return Math.ceil(x/10)*10; }

        // --- UI Generation
        function renderProcedureCheckboxes() {
            let html = "";
            PRECISION_PROC.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}" checked> ${p.name}</label>`; });
            NONPRECISION_PROC_250.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
            NONPRECISION_PROC_300.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
            NONPRECISION_PROC_350.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
            html += '<label><input type="checkbox" id="show_circling" checked> Circling</label>';
            document.getElementById('procedureCheckboxes').innerHTML = html;
        }
        renderProcedureCheckboxes();
        function renderCalculators() {
            let html = "";
            const catRows = (proc, inputTypes) => CATS.map(cat=>{
                let fields = '';
                // Note: The conversion logic only affects the DH/DA/MDH/MDA values, not the RVR/VIS fields.
                const daType = inputTypes.includes('DA') ? 'DA':'';
                const mdaType = inputTypes.includes('MDA') ? 'MDA':'';
                const dhType = inputTypes.includes('DH') ? 'DH':'';
                const mdhType = inputTypes.includes('MDH') ? 'MDH':'';

                if(daType) fields += `<input type="number" placeholder="DA" id="${proc}_${cat}_da">`;
                if(mdaType) fields += `<input type="number" placeholder="MDA" id="${proc}_${cat}_mda">`;
                if(dhType) fields += `<input type="number" placeholder="DH" id="${proc}_${cat}_dh">`;
                if(mdhType) fields += `<input type="number" placeholder="MDH" id="${proc}_${cat}_mdh">`;
                if(inputTypes.includes('RVR'))  fields += `<input type="number" placeholder="RVR" id="${proc}_${cat}_rvr">`;
                if(inputTypes.includes('VIS'))  fields += `<input type="number" placeholder="VIS" id="${proc}_${cat}_vis" step="0.1">`;
                
                return `<div class="cat-row"><div class="cat-label">CAT ${cat}</div>${fields}<div class="result" id="${proc}_${cat}_result"></div></div>`;
            }).join('');
            PRECISION_PROC.forEach(proc=>{
                html += `<div class="calculator" id="${proc.code}Calculator">
                    <h3>${proc.name}</h3>
                    ${catRows(proc.code, ['DA','DH','RVR'])}
                </div>`;
            });
            NONPRECISION_PROC_250.forEach(proc=>{
                html += `<div class="calculator" id="${proc.code}Calculator">
                    <h3>${proc.name}</h3>
                    ${catRows(proc.code, ['MDA','MDH','RVR'])}
                </div>`;
            });
            NONPRECISION_PROC_300.forEach(proc=>{
                html += `<div class="calculator" id="${proc.code}Calculator">
                    <h3>${proc.name}</h3>
                    ${catRows(proc.code, ['MDA','MDH','RVR'])}
                </div>`;
            });
            NONPRECISION_PROC_350.forEach(proc=>{
                html += `<div class="calculator" id="${proc.code}Calculator">
                    <h3>${proc.name}</h3>
                    ${catRows(proc.code, ['MDA','MDH','RVR'])}
                </div>`;
            });
            html += `<div class="calculator" id="circlingCalculator">
                <h3>Circling</h3>
                ${catRows('circling', ['MDA','MDH','VIS'])}
            </div>`;
            document.getElementById('calculatorsArea').innerHTML = html;
        }
        renderCalculators();
        function updateCalculatorVisibility() {
            [...PRECISION_PROC, ...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350, ...CIRCLING_PROC].forEach(proc=>{
                const show = document.getElementById('show_'+proc.code)?.checked;
                document.getElementById(proc.code+'Calculator').style.display = show ? 'block':'none';
            });
        }
        document.getElementById('procedureCheckboxes').addEventListener('change', updateCalculatorVisibility);
        updateCalculatorVisibility();

        document.getElementById('noncdfa').addEventListener('change',function(){
            const s = document.getElementById('noncdfa').checked;
            document.getElementById('noncdfaSubGroup').style.display = s ? 'flex':'none';
        });
        document.getElementById('cdfa').addEventListener('change',function(){
            document.getElementById('noncdfaSubGroup').style.display = 'none';
            document.getElementById('noncdfa_ab').checked = false;
            document.getElementById('noncdfa_cd').checked = false;
        });

        // --- MAIN LOGIC incl. ALL FEATURE/EXCEPTION RULES ---
        function calculate() {
            // NOTE: AD Elev and THR Elev are always considered FEET (no conversion)
            const adElev = parseFloat(document.getElementById('adElev').value)||0;
            const thrElev = parseFloat(document.getElementById('thrElev').value)||0;
            const lightType = document.getElementById('lightType').value;
            const useMeterConversion = document.getElementById('meterToFeetConversion').checked;

            // --- CDFA/Non-CDFA conditions ---
            const isProcCDFA = document.getElementById('cdfa').checked;
            const isNonCDFA = document.getElementById('noncdfa').checked;
            const isNonCDFA_AB = document.getElementById('noncdfa_ab').checked;
            const isNonCDFA_CD = document.getElementById('noncdfa_cd').checked;

            function isNonCDFAForCat(cat){
                if(!isNonCDFA) return false;
                if(!isNonCDFA_AB && !isNonCDFA_CD) return true;
                if(isNonCDFA_AB && isNonCDFA_CD) return true;
                if(isNonCDFA_AB && ['A','B'].includes(cat)) return true;
                if(isNonCDFA_CD && ['C','D'].includes(cat)) return true;
                return false;
            }

            // --- HELPER: Meter to Feet Conversion Rule ---
            // Input value (Meters) * 3.28084, then Round Up to integer (Feet)
            function toFeet(rawValue) {
                if (!rawValue && rawValue !== 0) return 0; // handle NaN/null/undefined
                if (rawValue === 0) return 0;
                // Only convert if the checkbox is ticked
                if (useMeterConversion) {
                    // Rule: input value * 3.28084 then ROUNDUP(val, 0)
                    return Math.ceil(rawValue * 3.28084);
                }
                // Otherwise, treat the raw value as feet
                return rawValue;
            }

            let summary = {};
            // --- PRECISION Approaches (incl. special LNAV/VNAV logic) ---
            PRECISION_PROC.forEach(proc=>{
                if(!document.getElementById('show_'+proc.code).checked) return;
                summary[proc.code] = {};
                CATS.forEach(cat=>{
                    // Grab raw input (Meters for DA/DH if checkbox is ticked)
                    const daRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_da`).value)||0;
                    const dhRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_dh`).value)||0;
                    
                    // Apply Conversion Rule (or return raw value if box unchecked)
                    const da = toFeet(daRaw);
                    const dh = toFeet(dhRaw);
                    
                    // RVR is NOT converted (standard aviation logic + user constraint)
                    const rvr = parseFloat(document.getElementById(`${proc.code}_${cat}_rvr`).value)||0;

                    // --- For LNAV/VNAV, min DH is 250, else 200
                    const dhRaised = (proc.code === "lnavvnav") ? Math.max(dh, 250) : Math.max(dh, 200);
                    const daCalc = thrElev + dhRaised;
                    const daFinal = Math.max(da, daCalc);
                    const rvrTable = getRVRFromTable(dhRaised,lightType);
                    let rvrFinal = Math.max(rvrTable, rvr); // Table is real minimum for precision
                    
                    // Apply RVR max limits if CDFA
                    if(!isNonCDFAForCat(cat)) {
                        const maxRVR = ['A','B'].includes(cat)?1500:2400;
                        if(rvrFinal>maxRVR && (!rvr || rvr<=maxRVR)) rvrFinal=maxRVR;
                    }
                    
                    const res = `DA: ${daFinal}(${dhRaised}), RVR: ${rvrFinal}m`;
                    // Check if any raw input exists to display result
                    document.getElementById(`${proc.code}_${cat}_result`).innerText = daRaw||dhRaw||rvr ? res : '';
                    summary[proc.code][cat] = daRaw||dhRaw||rvr ? res : '';
                });
            });
            // --- NONPRECISION Approaches (incl. >1200 MDH rule) ---
            [...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350].forEach(proc=>{
                if(!document.getElementById('show_'+proc.code).checked) return;
                summary[proc.code] = {};
                let minMDH = 250;
                if(NONPRECISION_PROC_300.some(p=>p.code===proc.code)) minMDH=300;
                if(NONPRECISION_PROC_350.some(p=>p.code===proc.code)) minMDH=350;
                CATS.forEach(cat=>{
                    // Grab raw input (Meters for MDA/MDH if checkbox is ticked)
                    const mdaRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_mda`).value)||0;
                    const mdhRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_mdh`).value)||0;
                    
                    // Apply Conversion Rule (or return raw value if box unchecked)
                    const mda = toFeet(mdaRaw);
                    const mdh = toFeet(mdhRaw);

                    const rvr = parseFloat(document.getElementById(`${proc.code}_${cat}_rvr`).value)||0;
                    
                    let mdhUsed = mdh;
                    let calcMDA = mda;
                    
                    if(mdh>0 && mdh<minMDH) {
                        mdhUsed = minMDH;
                        calcMDA = roundUpTo10(thrElev + mdhUsed);
                        if(mda>calcMDA) calcMDA = mda;
                    } else if(mdh>=minMDH) {
                        // MDH is >= minMDH, MDA value is taken as is unless it's lower than the calculated MDA based on MDH (unlikely if MDH is correct)
                        // But for consistency:
                        calcMDA = mda;
                    } else if (mdh === 0) {
                        // If only MDA is provided, use it
                        if (mda > 0) {
                            calcMDA = mda;
                            mdhUsed = mda - thrElev; // Calculate MDH from MDA for RVR table use
                        } else {
                            // If both are 0, use minMDH and calculate MDA
                            mdhUsed = minMDH;
                            calcMDA = roundUpTo10(thrElev + mdhUsed);
                        }
                    }

                    // --- New rule: If MDH > 1200 => always Non-CDFA, RVR = 5000m
                    if(mdhUsed > 1200) {
                        document.getElementById(`${proc.code}_${cat}_result`).innerText = 
                          `MDA: ${calcMDA}(${mdhUsed}), RVR: 5000m (forced Non-CDFA: MDH > 1200)`;
                        summary[proc.code][cat] = `MDA: ${calcMDA}(${mdhUsed}), RVR: 5000m (forced Non-CDFA: MDH > 1200)`;
                        return; // skip further RVR processing for this row
                    }

                    const rvrTable = getRVRFromTable(mdhUsed||minMDH, lightType);
                    let rvrFinal;
                    if(!isNonCDFAForCat(cat)) { // CDFA min 750, regular cap
                        rvrFinal = Math.max(750, rvrTable, rvr);
                        const maxRVR = ['A','B'].includes(cat)?1500:2400;
                        if(rvrFinal>maxRVR && (!rvr || rvr<=maxRVR)) rvrFinal=maxRVR;
                    } else { // Non-CDFA min 1000/1200
                        let minRVR = ['A','B'].includes(cat)?1000:1200;
                        rvrFinal = Math.max(minRVR, rvrTable, rvr);
                    }
                    const res = `MDA: ${calcMDA}(${mdhUsed}), RVR: ${rvrFinal}m`;
                    document.getElementById(`${proc.code}_${cat}_result`).innerText = mdaRaw||mdhRaw||rvr?res:"";
                    summary[proc.code][cat] = mdaRaw||mdhRaw||rvr?res:"";
                });
            });
            // --- CIRCLING (unchanged, no RVR logic)
            if(document.getElementById('show_circling').checked) {
                summary.circling = {};
                const catMins = {A:400,B:500,C:600,D:700};
                const visDefaults = {A:1.5,B:1.6,C:2.4,D:3.6};
                CATS.forEach(cat=>{
                    // Grab raw input (Meters for MDA/MDH if checkbox is ticked)
                    const mdaRaw = parseFloat(document.getElementById(`circling_${cat}_mda`).value)||0;
                    const mdhRaw = parseFloat(document.getElementById(`circling_${cat}_mdh`).value)||0;
                    
                    // Apply Conversion Rule (or return raw value if box unchecked)
                    const mda = toFeet(mdaRaw);
                    const mdh = toFeet(mdhRaw);

                    const vis = parseFloat(document.getElementById(`circling_${cat}_vis`).value)||0; // No change
                    
                    const mdhUsed = Math.max(mdh,catMins[cat]);
                    const mdaCalc = roundUpTo10(adElev+mdhUsed);
                    const mdaFinal = Math.max(mda,mdaCalc);
                    const visFinal = Math.max(vis||0, visDefaults[cat]);
                    const res = `MDA: ${mdaFinal}(${mdhUsed}), VIS: ${visFinal}km`;
                    document.getElementById(`circling_${cat}_result`).innerText = mdaRaw||mdhRaw||vis?res:"";
                    summary.circling[cat] = mdaRaw||mdhRaw||vis?res:"";
                });
            }
            updateSummaryResults(summary);
        }
        
        document.addEventListener('input',function(e){ 
            if(e.target.type==='number' || e.target.id === 'meterToFeetConversion') calculate(); 
        });
        document.addEventListener('change',function(e){
            if(['radio','checkbox','select-one'].includes(e.target.type)) {
                updateCalculatorVisibility();
                calculate();
            }
        });
        
        function clearAllInputs() {
            // Clear all numbers and text
            document.querySelectorAll('input[type="number"], input[type="text"]').forEach(el => el.value = '');

            // Reset all result blocks
            document.querySelectorAll('.result').forEach(el => el.innerText = '');
            document.getElementById('summaryResults').innerHTML = '';

            // Reset radio buttons: Default to CDFA
            document.getElementById('cdfa').checked = true;
            document.getElementById('noncdfa').checked = false;
            // Hide Non CDFA subgroup, uncheck suboptions
            document.getElementById('noncdfaSubGroup').style.display = 'none';
            document.getElementById('noncdfa_ab').checked = false;
            document.getElementById('noncdfa_cd').checked = false;
            
            // Reset conversion checkbox (new addition)
            document.getElementById('meterToFeetConversion').checked = false;


            // Set calculator checkboxes: RESET TO DEFAULT (Only Circling Checked)
            // 1. Uncheck all Precision and Non-Precision
            [
                ...PRECISION_PROC, 
                ...NONPRECISION_PROC_250, 
                ...NONPRECISION_PROC_300, 
                ...NONPRECISION_PROC_350
            ].forEach(proc => {
                let el = document.getElementById('show_'+proc.code);
                if(el) el.checked = false;
            });

            // 2. Check only Circling
            let circlingEl = document.getElementById('show_circling');
            if(circlingEl) circlingEl.checked = true;

            updateCalculatorVisibility();

            // Optional: scroll to top, focus the first input, or reset selects if you want
            window.scrollTo(0,0);
        }
        // ---- Top-right Page Zoom Controls ----
        let zoomLevel = 1;
        const minZoom = 0.7;
        const maxZoom = 2;

        function zoomPage(direction) {
            if(direction === '+') {
                zoomLevel = Math.min(maxZoom, zoomLevel + 0.1);
            } else if(direction === '-') {
                zoomLevel = Math.max(minZoom, zoomLevel - 0.1);
            }
            document.body.style.zoom = zoomLevel;
            document.getElementById('zoom-indicator').innerText = `Zoom: ${(zoomLevel*100).toFixed(0)}%`;
        }

        window.addEventListener('DOMContentLoaded',()=>{
            document.body.style.zoom = zoomLevel;
            document.getElementById('zoom-indicator').innerText = `Zoom: ${(zoomLevel*100).toFixed(0)}%`;
            calculate(); // Run initial calculation on load
        });
        
        // Advanced Summary Results with State logic
        function updateSummaryResults(results) {
            const useMeterConversion = document.getElementById('meterToFeetConversion').checked;
            
            // Helper function to get the actual feet value for comparison, taking conversion into account
            function getFeetValueForCheck(rawValue, applyConversion) {
                 if (!rawValue && rawValue !== 0) return 0;
                 if (applyConversion) {
                    return Math.ceil(rawValue * 3.28084);
                 }
                 return rawValue;
            }

            // Helper to parse result strings back to numbers for comparison
            // Matches format like: "MDA: 500(400), RVR: 1000m" or "DA: 200(100), VIS: 1.5km"
            function parseResultString(str) {
                if(!str) return null;
                // Regex breakdown:
                // Group 1: Altitude (DA/MDA)
                // Group 2: Height (DH/MDH) in parens
                // Group 3: Value
                // Group 4: Unit (m or km)
                const regex = /(?:DA|MDA|DH):\s*(\d+)\s*\((\d+)\),\s*(?:RVR|VIS):\s*([\d\.]+)(m|km)/i;
                const match = str.match(regex);
                if(!match) return null;
                return {
                    alt: parseInt(match[1]), // DA or MDA
                    hgt: parseInt(match[2]), // DH or MDH
                    vis: parseFloat(match[3]),
                    visVal: parseFloat(match[3]), // Raw value for display/check
                    unit: match[4].toLowerCase()
                };
            }

            let anyState = false;
            const blocks = [
                ...PRECISION_PROC,
                ...NONPRECISION_PROC_250,
                ...NONPRECISION_PROC_300,
                ...NONPRECISION_PROC_350,
                ...CIRCLING_PROC
            ].filter(proc => document.getElementById('show_'+proc.code)?.checked);
            
            function isStateValue(proc, cat, value) {
                let regulatoryMin = null;

                // Grab raw input (which is what the user would have entered)
                const dhRaw = parseFloat(document.getElementById(`${proc}_${cat}_dh`)?.value)||0;
                const mdhRaw = parseFloat(document.getElementById(`${proc}_${cat}_mdh`)?.value)||0;
                const rvrVisRaw = parseFloat(document.getElementById(`${proc}_${cat}_rvr`)?.value)||parseFloat(document.getElementById(`${proc}_${cat}_vis`)?.value)||0;

                // Determine if DA/DH/MDA/MDH was converted for this specific check
                const dhCheck = getFeetValueForCheck(dhRaw, useMeterConversion);
                const mdhCheck = getFeetValueForCheck(mdhRaw, useMeterConversion);
                
                if (PRECISION_PROC.some(p=>p.code===proc)) {
                    let dhRaised;
                    if(proc === "lnavvnav") {
                        dhRaised = Math.max(dhCheck, 250);
                    } else {
                        dhRaised = Math.max(dhCheck, 200);
                    }
                    regulatoryMin = getRVRFromTable(dhRaised, document.getElementById('lightType').value);
                } else if (CIRCLING_PROC.some(p=>p.code===proc)) {
                    regulatoryMin = {A:1.5,B:1.6,C:2.4,D:3.6}[cat];
                } else { // Non-Precision
                    let minMDH = 250;
                    if(NONPRECISION_PROC_300.some(p=>p.code===proc)) minMDH=300;
                    if(NONPRECISION_PROC_350.some(p=>p.code===proc)) minMDH=350;
                    let mdhUsed = mdhCheck > 0 ? Math.max(mdhCheck, minMDH) : minMDH;
                    if(mdhUsed > 1200) return value >= 5000;
                    
                    // Replicate Non-CDFA check from main logic
                    const isNonCDFA = document.getElementById('noncdfa').checked;
                    const isNonCDFA_AB = document.getElementById('noncdfa_ab').checked;
                    const isNonCDFA_CD = document.getElementById('noncdfa_cd').checked;
                    function isNonCDFAForCat(cat){
                        if(!isNonCDFA) return false;
                        if(!isNonCDFA_AB && !isNonCDFA_CD) return true;
                        if(isNonCDFA_AB && isNonCDFA_CD) return true;
                        if(isNonCDFA_AB && ['A','B'].includes(cat)) return true;
                        if(isNonCDFA_CD && ['C','D'].includes(cat)) return true;
                        return false;
                    }

                    const rvrTable = getRVRFromTable(mdhUsed, document.getElementById('lightType').value);
                    if(!isNonCDFAForCat(cat)) {
                        regulatoryMin = Math.max(750, rvrTable);
                    } else {
                        regulatoryMin = Math.max(['A','B'].includes(cat)?1000:1200, rvrTable);
                    }
                }
                
                if(rvrVisRaw == 0) return false;
                
                // Compare the user's RAW RVR/VIS input (no conversion for these fields) against the calculated regulatory minimum
                return rvrVisRaw > regulatoryMin;
            }
            
            let html = `<div style="display:flex;gap:14px;align-items:center;margin-bottom:12px;">`;
            html += `<span class="state-indicator state-standard" id="summaryStandardBox">STANDARD</span>`;
            html += `<span class="state-indicator" id="summaryStateBox">STATE</span>`;
            html += `</div>`;
            html += `<h2>Summary of Results</h2>`;
            blocks.forEach(proc=>{
                if(!results[proc.code])return;
                html += `<div style="margin-bottom:14px;"><h3>${proc.name}</h3>`;
                CATS.forEach(cat=>{
                    const resultText = results[proc.code][cat] || '';
                    let highlight = '';
                    let circlingNote = ''; // Variable to hold the warning text

                    if(resultText) {
                        // 1. Existing STATE Check
                        let m = /RVR:\s*(\d+(?:\.\d+)?)m/i.exec(resultText);
                        if(!m) m = /VIS:\s*(\d+(?:\.\d+)?)/i.exec(resultText);
                        if(m) {
                            let num = parseFloat(m[1]);
                            if(isStateValue(proc.code,cat,num)) {
                                highlight = "color:#be2222;font-weight:bold;";
                                anyState = true;
                            }
                        }

                        // 2. NEW LOGIC: Check vs Circling
                        // Only applicable if this procedure is NOT circling, and Circling results exist for this CAT
                        if(proc.code !== 'circling' && results.circling && results.circling[cat]) {
                            const procData = parseResultString(resultText);
                            const circData = parseResultString(results.circling[cat]);
                            
                            if (procData && circData) {
                                let warnings = [];
                                
                                // Compare Altitudes (DA/MDA vs Circling MDA)
                                if (procData.alt > circData.alt) {
                                    warnings.push("DA/MDA > Circling MDA");
                                }
                                // Compare Heights (DH/MDH vs Circling MDH)
                                if (procData.hgt > circData.hgt) {
                                     warnings.push("DH/MDH > Circling MDH");
                                }

                                // Compare Visibility
                                // Normalize both to meters for comparison
                                const procVisM = procData.unit === 'km' ? procData.vis * 1000 : procData.vis;
                                const circVisM = circData.unit === 'km' ? circData.vis * 1000 : circData.vis;

                                if (procVisM > circVisM) {
                                    warnings.push("RVR/VIS > Circling VIS");
                                }

                                if (warnings.length > 0) {
                                    circlingNote = `<span class="raise-circling-note">Raise Circling (${warnings.join(', ')})</span>`;
                                }
                            }
                        }
                    }
                    html += `<div>CAT ${cat}: <span style="${highlight}">${resultText}</span>${circlingNote}</div>`;
                });
                html += `</div>`;
            });
            document.getElementById('summaryResults').innerHTML = html;
            document.getElementById('summaryStandardBox').className = 'state-indicator'+(anyState?'':' state-standard');
            document.getElementById('summaryStateBox').className = 'state-indicator'+(anyState?' state-state':'');
        }
        // ==== AUTOCHECK: Select Only Circling By Default ====
        window.addEventListener('DOMContentLoaded', function() {
            // Uncheck all main procedure checkboxes (precision, non-precision)
            [
                ...PRECISION_PROC,
                ...NONPRECISION_PROC_250,
                ...NONPRECISION_PROC_300,
                ...NONPRECISION_PROC_350
            ].forEach(proc=>{
                var el = document.getElementById('show_'+proc.code);
                if(el) el.checked = false;
            });
            // Check only "Circling"
            var circ = document.getElementById('show_circling');
            if(circ) circ.checked = true;
            // Update the UI accordingly
            if (typeof updateCalculatorVisibility === 'function') updateCalculatorVisibility();
        });
    </script>
</body>
</html>
