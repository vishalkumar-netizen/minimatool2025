<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aviation Calculator - minimatool2025</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1300px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.08); }
        h1 { text-align: center; color: #333; margin-bottom: 30px; }
        
        /* Inputs Area */
        .top-inputs { display: flex; gap: 20px; margin-bottom: 15px; align-items: center; flex-wrap: wrap; }
        .input-group { display: flex; flex-direction: column; gap: 5px; }
        .input-group label { font-weight: bold; color: #555; }
        .input-group input, .input-group select { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 120px; }
        
        /* Procedure Selection */
        .procedure-group { display: flex; align-items: center; gap: 10px; }
        .noncdfa-sub-group { margin-left: 12px; display: flex; gap: 10px;}
        .proc-checkbox-group { margin: 16px 0 10px 0; display: flex; flex-wrap: wrap; gap: 14px; }
        
        /* Calculators Grid */
        .calculators { display: flex; gap: 20px; margin-top: 20px; flex-wrap: wrap; }
        .calculator { flex: 1 1 350px; border: 2px solid #ddd; border-radius: 8px; padding: 15px; min-width: 340px; margin-bottom: 15px; }
        .calculator h3 { text-align: center; margin-bottom: 15px; color: #333; background: #f8f8f8; padding: 10px; border-radius: 4px; }
        
        /* Rows */
        .cat-row { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px; background: #fafafa; border-radius: 4px; }
        .cat-label { font-weight: bold; width: 55px; color: #555; }
        .cat-row input { width: 75px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
        .result { margin-left: 12px; font-weight: bold; color: #0066cc; font-size: 0.96em;}
        
        /* Buttons */
        .calculate-btn { background: #007bff; color: white; padding: 12px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 24px auto; display: block; }
        .calculate-btn:hover { background: #0056b3; }
        
        /* Summary Section */
        #summaryResults { border-top:1px solid #ccc; padding-top:20px; margin-top:26px;}
        #summaryResults h2 { text-align:center; margin-bottom:15px;}
        #summaryResults h3 { margin-bottom:0;}
        
        /* State/Label Indicators */
        .state-indicator {
            display: inline-block;
            min-width: 90px;
            font-weight: bold;
            text-align: center;
            padding: 7px 18px;
            border-radius: 7px;
            margin-right: 12px;
            font-size: 16px;
        }
        .state-standard {
            background: #e2fbe0;
            color: #208c2c;
            border: 2px solid #30ba4c;
        }
        .state-state {
            background: #ffd6d6;
            color: #be2222;
            border: 2px solid #da3131;
        }
        .state-circling {
            background: #e0f7fa;
            color: #0277bd;
            border: 2px solid #0277bd;
        }

        /* Circling @ Table Styling */
        .circling-at-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.95em;
        }
        .circling-at-table th, .circling-at-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .circling-at-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .circling-section-title {
            margin-top: 30px;
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .footer { text-align: center; margin-top: 26px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 14px; }
        
        @media (max-width: 800px) {
          .calculators { flex-direction: column; }
          .top-inputs { flex-direction: column; align-items: flex-start; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Minima Calculator</h1>
        <div class="top-inputs">
            <div class="input-group">
                <label>AD Elev (ft)</label>
                <input type="number" id="adElev" placeholder="0">
            </div>
            <div class="input-group">
                <label>THR Elev (ft)</label>
                <input type="number" id="thrElev" placeholder="0">
            </div>
            <div class="input-group">
                <label>ALS</label>
                <select id="lightType">
                    <option value="FALS">FALS</option>
                    <option value="IALS">IALS</option>
                    <option value="BALS">BALS</option>
                    <option value="NALS">NALS</option>
                </select>
            </div>
            <div class="procedure-group">
                <label>Procedure:</label>
                <input type="radio" name="procedure" value="CDFA" id="cdfa" checked>
                <label for="cdfa">CDFA</label>
                <input type="radio" name="procedure" value="Non-CDFA" id="noncdfa">
                <label for="noncdfa">NFC</label>
                <div id="noncdfaSubGroup" class="noncdfa-sub-group" style="display:none;">
                    <label><input type="checkbox" id="noncdfa_ab"> CAT A/B only</label>
                    <label><input type="checkbox" id="noncdfa_cd"> CAT C/D only</label>
                </div>
            </div>
            <!-- NEW: Meter to Feet Checkbox -->
            <div class="input-group" style="flex-direction:row; align-items:center; width:auto; border: 1px solid #ccc; padding: 5px 10px; border-radius: 4px; background: #fff;">
                <input type="checkbox" id="metricConversion" style="width:auto; margin-right:8px; transform: scale(1.2);">
                <label for="metricConversion" style="margin:0; cursor:pointer;">Meter to Feet Conversion</label>
            </div>
        </div>
        <div class="proc-checkbox-group" id="procedureCheckboxes"></div>
        <div class="calculators" id="calculatorsArea"></div>
        
        <button class="calculate-btn" onclick="calculate()">Calculate All</button>
        <button class="calculate-btn" type="button" onclick="clearAllInputs()" style="background:#6c757d; margin-top: 10px;">Clear All</button>
        
        <div id="summaryResults"></div>
        
        <div class="footer">
            This tool was created by Vishal Kumar Basson, Other Contributer - Shubham Bundele (Add Circling Rasie feature)
        </div>
    </div>

    <!-- ============ Fixed Top-Right Zoom Controls ============ -->
    <div id="page-zoom-controls" style="
      position: fixed;
      top: 18px; 
      right: 24px; 
      z-index: 2000;
      display: flex; 
      gap: 10px; 
      align-items:center;
      background: rgba(245,245,245,0.96); 
      border-radius:8px;
      padding: 8px 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    ">
      <button type="button" onclick="zoomPage('+')" title="Zoom in" style="font-size:18px;">+</button>
      <button type="button" onclick="zoomPage('-')" title="Zoom out" style="font-size:18px;">-</button>
      <span id="zoom-indicator" style="margin-left:8px;font-size:14px; color:#444;"></span>
    </div>

<script>
// === Define Procedures ===
const PRECISION_PROC = [
    { code: 'cat1', name: 'CAT 1' }, { code: 'rnp', name: 'RNP' }, { code: 'gls', name: 'GLS' },
    { code: 'par', name: 'PAR' }, { code: 'lpv', name: 'LPV' }, { code: 'lnavvnav', name: 'LNAV/VNAV' }
];
const NONPRECISION_PROC_250 = [
    { code: 'loc', name: 'LOC' }, { code: 'locdme', name: 'LOC+DME' }, { code: 'vordme', name: 'VOR+DME' },
    { code: 'lnav', name: 'LNAV' }, { code: 'sra', name: 'SRA' }, { code: 'lda', name: 'LDA' }
];
const NONPRECISION_PROC_300 = [
    { code: 'vor', name: 'VOR' }, { code: 'ndbdme', name: 'NDB+DME' }
];
const NONPRECISION_PROC_350 = [{ code: 'ndb', name: 'NDB' }];
const CIRCLING_PROC = [{ code: 'circling', name: 'Circling' }];
const CATS = ['A','B','C','D'];

// Standard Circling Minima Defaults (MDH in ft, VIS in km)
const CIRCLING_DEFAULTS = {
    A: { mdh: 400, vis: 1.5 },
    B: { mdh: 500, vis: 1.6 },
    C: { mdh: 600, vis: 2.4 },
    D: { mdh: 700, vis: 3.6 }
};

// RVR Table
const RVR_TABLE_RANGES = [
    {low: 200, high: 210, FALS: 550, IALS: 750, BALS: 1000, NALS: 1200},
    {low: 211, high: 220, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
    {low: 221, high: 230, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
    {low: 231, high: 240, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
    {low: 241, high: 250, FALS: 550, IALS: 800, BALS: 1000, NALS: 1300},
    {low: 251, high: 260, FALS: 600, IALS: 800, BALS: 1100, NALS: 1300},
    {low: 261, high: 280, FALS: 600, IALS: 900, BALS: 1100, NALS: 1300},
    {low: 281, high: 300, FALS: 650, IALS: 900, BALS: 1200, NALS: 1400},
    {low: 301, high: 320, FALS: 700, IALS: 1000, BALS: 1200, NALS: 1400},
    {low: 321, high: 340, FALS: 800, IALS: 1100, BALS: 1300, NALS: 1500},
    {low: 341, high: 360, FALS: 900, IALS: 1200, BALS: 1400, NALS: 1600},
    {low: 361, high: 380, FALS: 1000, IALS: 1300, BALS: 1500, NALS: 1700},
    {low: 381, high: 400, FALS: 1100, IALS: 1400, BALS: 1600, NALS: 1800},
    {low: 401, high: 420, FALS: 1200, IALS: 1500, BALS: 1700, NALS: 1900},
    {low: 421, high: 440, FALS: 1300, IALS: 1600, BALS: 1800, NALS: 2000},
    {low: 441, high: 460, FALS: 1400, IALS: 1700, BALS: 1900, NALS: 2100},
    {low: 461, high: 480, FALS: 1500, IALS: 1800, BALS: 2000, NALS: 2200},
    {low: 481, high: 500, FALS: 1500, IALS: 1800, BALS: 2100, NALS: 2300},
    {low: 501, high: 520, FALS: 1600, IALS: 1900, BALS: 2100, NALS: 2400},
    {low: 521, high: 540, FALS: 1700, IALS: 2000, BALS: 2200, NALS: 2400},
    {low: 541, high: 560, FALS: 1800, IALS: 2100, BALS: 2300, NALS: 2500},
    {low: 561, high: 580, FALS: 1900, IALS: 2200, BALS: 2400, NALS: 2600},
    {low: 581, high: 600, FALS: 2000, IALS: 2300, BALS: 2500, NALS: 2700},
    {low: 601, high: 620, FALS: 2100, IALS: 2400, BALS: 2600, NALS: 2800},
    {low: 621, high: 640, FALS: 2200, IALS: 2500, BALS: 2700, NALS: 2900},
    {low: 641, high: 660, FALS: 2300, IALS: 2600, BALS: 2800, NALS: 3000},
    {low: 661, high: 680, FALS: 2400, IALS: 2700, BALS: 2900, NALS: 3100},
    {low: 681, high: 700, FALS: 2500, IALS: 2800, BALS: 3000, NALS: 3200},
    {low: 701, high: 720, FALS: 2600, IALS: 2900, BALS: 3100, NALS: 3300},
    {low: 721, high: 740, FALS: 2700, IALS: 3000, BALS: 3200, NALS: 3400},
    {low: 741, high: 760, FALS: 2700, IALS: 3000, BALS: 3300, NALS: 3500},
    {low: 761, high: 800, FALS: 2900, IALS: 3200, BALS: 3400, NALS: 3600},
    {low: 801, high: 850, FALS: 3100, IALS: 3400, BALS: 3600, NALS: 3800},
    {low: 851, high: 900, FALS: 3300, IALS: 3600, BALS: 3800, NALS: 4000},
    {low: 901, high: 950, FALS: 3600, IALS: 3900, BALS: 4100, NALS: 4300},
    {low: 951, high: 1000, FALS: 3800, IALS: 4100, BALS: 4300, NALS: 4500},
    {low: 1001, high: 1100, FALS: 4100, IALS: 4400, BALS: 4600, NALS: 4900},
    {low: 1101, high: 1200, FALS: 4600, IALS: 4900, BALS: 5000, NALS: 5000},
    {low: 1201, high: 9999, FALS: 5000, IALS: 5000, BALS: 5000, NALS: 5000}
];

function getRVRFromTable(dh, lightType) {
    for (let row of RVR_TABLE_RANGES) {
        if (dh >= row.low && dh <= row.high) return row[lightType];
    }
    return RVR_TABLE_RANGES[RVR_TABLE_RANGES.length-1][lightType];
}
function roundUpTo10(x) { return Math.ceil(x/10)*10; }

// --- UI Generation ---
function renderProcedureCheckboxes() {
    let html = "";
    PRECISION_PROC.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}" checked> ${p.name}</label>`; });
    NONPRECISION_PROC_250.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
    NONPRECISION_PROC_300.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
    NONPRECISION_PROC_350.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
    html += '<label><input type="checkbox" id="show_circling" checked> Circling</label>';
    document.getElementById('procedureCheckboxes').innerHTML = html;
}
renderProcedureCheckboxes();

function renderCalculators() {
    let html = "";
    const catRows = (proc, inputTypes) => CATS.map(cat=>{
        let fields = '';
        if(inputTypes.includes('DA'))   fields += `<input type="number" placeholder="DA" id="${proc}_${cat}_da">`;
        if(inputTypes.includes('MDA'))  fields += `<input type="number" placeholder="MDA" id="${proc}_${cat}_mda">`;
        if(inputTypes.includes('DH'))   fields += `<input type="number" placeholder="DH" id="${proc}_${cat}_dh">`;
        if(inputTypes.includes('MDH'))  fields += `<input type="number" placeholder="MDH" id="${proc}_${cat}_mdh">`;
        if(inputTypes.includes('RVR'))  fields += `<input type="number" placeholder="RVR" id="${proc}_${cat}_rvr">`;
        if(inputTypes.includes('VIS'))  fields += `<input type="number" placeholder="VIS" id="${proc}_${cat}_vis" step="0.1">`;
        return `<div class="cat-row"><div class="cat-label">CAT ${cat}</div>${fields}<div class="result" id="${proc}_${cat}_result"></div></div>`;
    }).join('');

    const renderGroup = (arr, typeInputs) => {
        arr.forEach(proc => {
            html += `<div class="calculator" id="${proc.code}Calculator">
                <h3>${proc.name}</h3>
                ${catRows(proc.code, typeInputs)}
            </div>`;
        });
    };

    renderGroup(PRECISION_PROC, ['DA','DH','RVR']);
    renderGroup(NONPRECISION_PROC_250, ['MDA','MDH','RVR']);
    renderGroup(NONPRECISION_PROC_300, ['MDA','MDH','RVR']);
    renderGroup(NONPRECISION_PROC_350, ['MDA','MDH','RVR']);

    html += `<div class="calculator" id="circlingCalculator">
        <h3>Circling</h3>
        ${catRows('circling', ['MDA','MDH','VIS'])}
    </div>`;
    document.getElementById('calculatorsArea').innerHTML = html;
}
renderCalculators();

function updateCalculatorVisibility() {
    [...PRECISION_PROC, ...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350, ...CIRCLING_PROC].forEach(proc=>{
        const show = document.getElementById('show_'+proc.code)?.checked;
        const el = document.getElementById(proc.code+'Calculator');
        if(el) el.style.display = show ? 'block':'none';
    });
}
document.getElementById('procedureCheckboxes').addEventListener('change', updateCalculatorVisibility);
updateCalculatorVisibility();

document.getElementById('noncdfa').addEventListener('change',function(){
    const s = document.getElementById('noncdfa').checked;
    document.getElementById('noncdfaSubGroup').style.display = s ? 'flex':'none';
});
document.getElementById('cdfa').addEventListener('change',function(){
    document.getElementById('noncdfaSubGroup').style.display = 'none';
    document.getElementById('noncdfa_ab').checked = false;
    document.getElementById('noncdfa_cd').checked = false;
});

// --- MAIN LOGIC ---
function calculate() {
    const adElev = parseFloat(document.getElementById('adElev').value)||0;
    const thrElev = parseFloat(document.getElementById('thrElev').value)||0;
    const lightType = document.getElementById('lightType').value;

    const isProcCDFA = document.getElementById('cdfa').checked;
    const isNonCDFA = document.getElementById('noncdfa').checked;
    const isNonCDFA_AB = document.getElementById('noncdfa_ab').checked;
    const isNonCDFA_CD = document.getElementById('noncdfa_cd').checked;
    
    // NEW: Check for Meter Conversion
    const useMetricConversion = document.getElementById('metricConversion').checked;

    // Helper to get Altitude (MDA/DH/DA/MDH) respecting conversion
    function getAltInput(id) {
        const val = parseFloat(document.getElementById(id).value) || 0;
        if (val === 0) return 0;
        if (useMetricConversion) {
            // Formula: ROUNDUP(value * 3.28084, 0)
            return Math.ceil(val * 3.28084);
        }
        return val;
    }

    function isNonCDFAForCat(cat){
        if(!isNonCDFA) return false;
        if(!isNonCDFA_AB && !isNonCDFA_CD) return true;
        if(isNonCDFA_AB && isNonCDFA_CD) return true;
        if(isNonCDFA_AB && ['A','B'].includes(cat)) return true;
        if(isNonCDFA_CD && ['C','D'].includes(cat)) return true;
        return false;
    }

    let summary = {}; 
    let circlingBaselines = {};

    // 1. Calculate Standard Circling first
    if(document.getElementById('show_circling').checked) {
        summary.circling = {};
        CATS.forEach(cat=>{
            // Use getAltInput for MDA/MDH
            const mda = getAltInput(`circling_${cat}_mda`);
            const mdh = getAltInput(`circling_${cat}_mdh`);
            const vis = parseFloat(document.getElementById(`circling_${cat}_vis`).value)||0;
            
            const minMDH = CIRCLING_DEFAULTS[cat].mdh;
            const mdhUsed = Math.max(mdh, minMDH);
            const mdaCalc = roundUpTo10(adElev + mdhUsed);
            const mdaFinal = Math.max(mda, mdaCalc);
            
            const minVis = CIRCLING_DEFAULTS[cat].vis;
            const visFinal = Math.max(vis||0, minVis);

            const resText = `MDA: ${mdaFinal}(${mdhUsed}), VIS: ${visFinal}km`;
            
            // Check original raw input to see if user typed anything
            const rawMda = parseFloat(document.getElementById(`circling_${cat}_mda`).value)||0;
            const rawMdh = parseFloat(document.getElementById(`circling_${cat}_mdh`).value)||0;

            document.getElementById(`circling_${cat}_result`).innerText = rawMda||rawMdh||vis ? resText : "";
            summary.circling[cat] = rawMda||rawMdh||vis ? resText : "";
            circlingBaselines[cat] = {
                mda: mdaFinal,
                mdh: mdhUsed,
                vis: visFinal
            };
        });
    } else {
        CATS.forEach(cat => {
            circlingBaselines[cat] = {
                mda: roundUpTo10(adElev + CIRCLING_DEFAULTS[cat].mdh),
                mdh: CIRCLING_DEFAULTS[cat].mdh,
                vis: CIRCLING_DEFAULTS[cat].vis
            };
        });
    }

    // 2. Calculate Straight-In Procedures
    const precisionList = PRECISION_PROC;
    const nonPrecList = [...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350];

    const storeResult = (procCode, cat, text, rawData) => {
        if(!summary[procCode]) summary[procCode] = {};
        summary[procCode][cat] = { text: text, raw: rawData };
        document.getElementById(`${procCode}_${cat}_result`).innerText = text;
    };

    // Helper: Determine System Min and CDFA/Prec Cap
    const getSystemLimits = (cat, isPrec, isNFC) => {
        if(isPrec) {
             // PRECISION: Min 550m, Cap 1500m (A/B) or 2400m (C/D)
             return { 
                 min: 550, 
                 cap: ['A','B'].includes(cat) ? 1500 : 2400 
             }; 
        }
        if(isNFC) {
            // Non-CDFA
            return { min: ['A','B'].includes(cat) ? 1000 : 1200, cap: 99999 };
        }
        // CDFA Non-Prec
        return { 
            min: 750, 
            cap: ['A','B'].includes(cat) ? 1500 : 2400 
        };
    };

    // Helper: Parse Input (Detect VIS vs RVR)
    const parseRVRInput = (val) => {
        let isVis = false;
        let meters = 0;
        
        if (val > 0 && val < 10) {
            isVis = true;
            meters = val * 1000;
        } else {
            isVis = false;
            meters = val;
        }
        return { isVis, meters };
    };

    // --- PRECISION ---
    precisionList.forEach(proc=>{
        if(!document.getElementById('show_'+proc.code).checked) return;
        CATS.forEach(cat=>{
            // Use getAltInput for DA/DH
            const da = getAltInput(`${proc.code}_${cat}_da`);
            const dh = getAltInput(`${proc.code}_${cat}_dh`);
            const rvrRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_rvr`).value)||0;
            
            // Check existence based on original input to avoid calculating on '0' if empty
            const rawDa = parseFloat(document.getElementById(`${proc.code}_${cat}_da`).value)||0;
            const rawDh = parseFloat(document.getElementById(`${proc.code}_${cat}_dh`).value)||0;

            if(!rawDa && !rawDh && !rvrRaw) {
                storeResult(proc.code, cat, "", null);
                return;
            }

            const inputData = parseRVRInput(rvrRaw);
            const rvrMeters = inputData.meters;

            const dhRaised = (proc.code === "lnavvnav") ? Math.max(dh, 250) : Math.max(dh, 200);
            const daCalc = thrElev + dhRaised;
            const daFinal = Math.max(da, daCalc);
            const rvrTable = getRVRFromTable(dhRaised, lightType);
            
            const limits = getSystemLimits(cat, true, false);
            const cap = limits.cap; 

            // STANDARD: Max(Table, 550), Capped at 1500/2400
            let standardVis = Math.max(rvrTable, limits.min);
            if(standardVis > cap) standardVis = cap; // Strict Cap on Standard

            // RESULT LOGIC
            let rvrFinal = 0;
            if (rvrMeters > 0) {
                 // The floor for comparison is the CAPPED Standard, not the Raw Table.
                 // This ensures 1900m Input is accepted even if Table is 2900m,
                 // because 1900m > 1500m (Standard Cap).
                 rvrFinal = Math.max(rvrMeters, standardVis);
            } else {
                 rvrFinal = standardVis;
            }

            // Output String Formatting
            let res = `DA: ${daFinal}(${dhRaised}), `;
            if (inputData.isVis || (rvrFinal === rvrMeters && inputData.isVis)) {
                 res += `VIS: ${(rvrFinal/1000).toFixed(1)}km`;
            } else {
                 res += `RVR: ${rvrFinal}m`;
            }

            storeResult(proc.code, cat, res, {
                type: 'precision',
                val_alt: daFinal, 
                val_h: dhRaised, 
                val_vis: rvrFinal,
                std_vis: standardVis 
            });
        });
    });

    // --- NON-PRECISION ---
    nonPrecList.forEach(proc=>{
        if(!document.getElementById('show_'+proc.code).checked) return;
        
        let minMDH = 250;
        if(NONPRECISION_PROC_300.some(p=>p.code===proc.code)) minMDH=300;
        if(NONPRECISION_PROC_350.some(p=>p.code===proc.code)) minMDH=350;

        CATS.forEach(cat=>{
            // Use getAltInput for MDA/MDH
            const mda = getAltInput(`${proc.code}_${cat}_mda`);
            const mdh = getAltInput(`${proc.code}_${cat}_mdh`);
            const rvrRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_rvr`).value)||0;

            // Check existence based on original input
            const rawMda = parseFloat(document.getElementById(`${proc.code}_${cat}_mda`).value)||0;
            const rawMdh = parseFloat(document.getElementById(`${proc.code}_${cat}_mdh`).value)||0;

            if(!rawMda && !rawMdh && !rvrRaw) {
                storeResult(proc.code, cat, "", null);
                return;
            }

            let mdhUsed = mdh;
            let calcMDA = mda;

            if(mdh > 0 && mdh < minMDH) {
                mdhUsed = minMDH;
                calcMDA = roundUpTo10(thrElev + mdhUsed);
                if(mda > calcMDA) calcMDA = mda;
            } else if(mdh >= minMDH) {
                calcMDA = mda;
            } else {
                 if(mda > 0) {
                     let derivedMDH = mda - thrElev;
                     if(derivedMDH < minMDH) { derivedMDH = minMDH; calcMDA = roundUpTo10(thrElev+minMDH); }
                     mdhUsed = derivedMDH;
                 } else {
                     mdhUsed = minMDH;
                     calcMDA = roundUpTo10(thrElev + minMDH);
                 }
            }
            
            // Forced Non-CDFA rule (MDH > 1200)
            if(mdhUsed > 1200) {
                const res = `MDA: ${calcMDA}(${mdhUsed}), RVR: 5000m (forced Non-CDFA: MDH > 1200)`;
                storeResult(proc.code, cat, res, {
                    type: 'nonprec',
                    val_alt: calcMDA,
                    val_h: mdhUsed,
                    val_vis: 5000,
                    std_vis: 5000
                });
                return; 
            }

            const inputData = parseRVRInput(rvrRaw);
            const rvrMeters = inputData.meters;

            const rvrTable = getRVRFromTable(mdhUsed, lightType);
            const isNFC = isNonCDFAForCat(cat);
            const limits = getSystemLimits(cat, false, isNFC);

            // STANDARD VIS (Green Baseline)
            let standardVis = Math.max(rvrTable, limits.min);
            if (!isNFC) {
                if(standardVis > limits.cap) standardVis = limits.cap; // Strict Cap on Standard
            }

            // FINAL VIS (Result)
            let rvrFinal = 0;
            if (rvrMeters > 0) { 
                if (isNFC) {
                     // Non-CDFA logic: User cannot undercut Table (no caps)
                     let floor = Math.max(limits.min, rvrTable);
                     rvrFinal = Math.max(rvrMeters, floor);
                } else {
                     // CDFA Logic
                     // Comparison against Capped Standard
                     rvrFinal = Math.max(rvrMeters, standardVis);
                }
            } else {
                 rvrFinal = standardVis;
            }

            // Formatting
            let res = `MDA: ${calcMDA}(${mdhUsed}), `;
            if (inputData.isVis || (rvrFinal === rvrMeters && inputData.isVis)) {
                 res += `VIS: ${(rvrFinal/1000).toFixed(1)}km`;
            } else {
                 res += `RVR: ${rvrFinal}m`;
            }

            storeResult(proc.code, cat, res, {
                type: 'nonprec',
                val_alt: calcMDA,
                val_h: mdhUsed,
                val_vis: rvrFinal,
                std_vis: standardVis 
            });
        });
    });

    updateSummaryResults(summary, circlingBaselines);
}

function updateSummaryResults(summary, circlingBaselines) {
    let anyState = false;
    let anyBlueCircling = false;

    function isStateValue(proc, cat, data) {
        if(proc === 'circling') {
             const m = /VIS:\s*(\d+(?:\.\d+)?)/i.exec(data);
             if(m) {
                 const val = parseFloat(m[1]);
                 return val > CIRCLING_DEFAULTS[cat].vis; 
             }
             return false;
        }
        if (data.raw) {
             return data.raw.val_vis !== data.raw.std_vis;
        }
        return false;
    }

    let html = `<div style="display:flex;gap:14px;align-items:center;margin-bottom:12px;">`;
    html += `<span class="state-indicator state-standard" id="summaryStandardBox">STANDARD</span>`;
    html += `<span class="state-indicator" id="summaryStateBox">STATE</span>`;
    html += `<span class="state-indicator" id="summaryCirclingBox" style="display:none;">CIRCLING</span>`; 
    html += `</div>`;
    html += `<h2>Summary of Results</h2>`;

    const allProcs = [
        ...PRECISION_PROC, ...NONPRECISION_PROC_250, 
        ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350, 
        ...CIRCLING_PROC
    ];

    allProcs.forEach(proc => {
        if(!document.getElementById('show_'+proc.code)?.checked) return;
        if(!summary[proc.code]) return;
        
        let procHtml = `<div style="margin-bottom:14px;"><h3>${proc.name}</h3>`;
        let hasContent = false;

        CATS.forEach(cat => {
            const data = summary[proc.code][cat];
            const resultText = (typeof data === 'string') ? data : (data ? data.text : '');
            
            if(!resultText) return;
            hasContent = true;

            let highlight = '';
            
            if(isStateValue(proc.code, cat, data)) {
                highlight = "color:#be2222;font-weight:bold;";
                anyState = true;
            }

            let showBlueLabel = false;
            if(proc.code !== 'circling' && data.raw) {
                const stdCirc = circlingBaselines[cat];
                const siVisKm = data.raw.val_vis / 1000;
                
                if (data.raw.val_h > stdCirc.mdh || siVisKm > stdCirc.vis) {
                    showBlueLabel = true;
                    anyBlueCircling = true;
                }
            }

            let labelHtml = showBlueLabel ? `<span style="color:#0277bd; font-weight:bold; margin-left:8px; font-size:0.9em;">(CIRCLING)</span>` : '';

            procHtml += `<div>CAT ${cat}: <span style="${highlight}">${resultText}</span>${labelHtml}</div>`;
        });
        procHtml += `</div>`;
        
        if(hasContent) html += procHtml;
    });

    let circlingAtRows = "";
    allProcs.forEach(proc => {
        if(proc.code === 'circling') return; 
        if(!document.getElementById('show_'+proc.code)?.checked) return;
        if(!summary[proc.code]) return;

        CATS.forEach(cat => {
            const data = summary[proc.code][cat];
            if(!data || !data.raw) return;

            const stdCirc = circlingBaselines[cat];
            const siVisKm = data.raw.val_vis / 1000;

            if (data.raw.val_h > stdCirc.mdh || siVisKm > stdCirc.vis) {
                const newMDH = Math.max(data.raw.val_h, stdCirc.mdh);
                const adElev = parseFloat(document.getElementById('adElev').value)||0;
                const newMDA = roundUpTo10(adElev + newMDH);
                const newVis = Math.max(siVisKm, stdCirc.vis);

                circlingAtRows += `
                    <tr>
                        <td><strong>${proc.name}</strong></td>
                        <td>CAT ${cat}</td>
                        <td>MDA: ${newMDA} (${newMDH})</td>
                        <td>VIS: ${newVis.toFixed(1)} km</td>
                    </tr>
                `;
            }
        });
    });

    if (circlingAtRows !== "") {
        html += `<h3 class="circling-section-title">Circling @ (Raised Minima)</h3>`;
        html += `<table class="circling-at-table">
                    <thead>
                        <tr>
                            <th>Procedure</th>
                            <th>CAT</th>
                            <th>Minima</th>
                            <th>Visibility</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${circlingAtRows}
                    </tbody>
                 </table>`;
        anyBlueCircling = true; 
    }

    document.getElementById('summaryResults').innerHTML = html;

    document.getElementById('summaryStandardBox').className = 'state-indicator' + (anyState ? '' : ' state-standard');
    document.getElementById('summaryStateBox').className = 'state-indicator' + (anyState ? ' state-state' : '');
    
    const circBox = document.getElementById('summaryCirclingBox');
    if(anyBlueCircling) {
        circBox.style.display = 'inline-block';
        circBox.className = 'state-indicator state-circling';
    } else {
        circBox.style.display = 'none';
    }
}

// --- Event Listeners ---
document.addEventListener('input', function(e){ if(e.target.type==='number') calculate(); });
document.addEventListener('change', function(e){
    if(['radio','checkbox','select-one'].includes(e.target.type)) {
        updateCalculatorVisibility();
        calculate();
    }
});

// --- Utils ---
function clearAllInputs() {
    document.querySelectorAll('input[type="number"], input[type="text"]').forEach(el => el.value = '');
    document.querySelectorAll('.result').forEach(el => el.innerText = '');
    document.getElementById('summaryResults').innerHTML = '';
    
    document.getElementById('cdfa').checked = true;
    document.getElementById('noncdfa').checked = false;
    document.getElementById('noncdfaSubGroup').style.display = 'none';
    document.getElementById('noncdfa_ab').checked = false;
    document.getElementById('noncdfa_cd').checked = false;
    document.getElementById('metricConversion').checked = false; // Reset metric toggle

    [...PRECISION_PROC, ...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350].forEach(proc => {
        let el = document.getElementById('show_'+proc.code);
        if(el) el.checked = false;
    });
    let circ = document.getElementById('show_circling');
    if(circ) circ.checked = true;

    updateCalculatorVisibility();
    window.scrollTo(0,0);
}

// --- Zoom Controls ---
let zoomLevel = 1;
const minZoom = 0.7;
const maxZoom = 2;

function zoomPage(direction) {
    if(direction === '+') {
        zoomLevel = Math.min(maxZoom, zoomLevel + 0.1);
    } else if(direction === '-') {
        zoomLevel = Math.max(minZoom, zoomLevel - 0.1);
    }
    document.body.style.zoom = zoomLevel;
    document.getElementById('zoom-indicator').innerText = `Zoom: ${(zoomLevel*100).toFixed(0)}%`;
}

// --- Init ---
window.addEventListener('DOMContentLoaded', function() {
    document.body.style.zoom = zoomLevel;
    document.getElementById('zoom-indicator').innerText = `Zoom: ${(zoomLevel*100).toFixed(0)}%`;

    [...PRECISION_PROC, ...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350].forEach(proc=>{
        var el = document.getElementById('show_'+proc.code);
        if(el) el.checked = false;
    });
    var circ = document.getElementById('show_circling');
    if(circ) circ.checked = true;
    
    updateCalculatorVisibility();
});
</script>
</body>
</html>
