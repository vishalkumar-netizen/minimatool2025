<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aviation Calculator - minimatool2025</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1300px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.08); }
        h1 { text-align: center; color: #333; margin-bottom: 30px; }
        .top-inputs { display: flex; gap: 20px; margin-bottom: 15px; align-items: center; flex-wrap: wrap; }
        .input-group { display: flex; flex-direction: column; gap: 5px; }
        .input-group label { font-weight: bold; color: #555; }
        .input-group input, .input-group select { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 120px; }
        .procedure-group { display: flex; align-items: center; gap: 10px; }
        .noncdfa-sub-group { margin-left: 12px; display: flex; gap: 10px;}
        .proc-checkbox-group { margin: 16px 0 10px 0; display: flex; flex-wrap: wrap; gap: 14px; }
        .calculators { display: flex; gap: 20px; margin-top: 20px; flex-wrap: wrap; }
        .calculator { flex: 1 1 350px; border: 2px solid #ddd; border-radius: 8px; padding: 15px; min-width: 340px; margin-bottom: 15px; }
        .calculator h3 { text-align: center; margin-bottom: 15px; color: #333; background: #f8f8f8; padding: 10px; border-radius: 4px; }
        .cat-row { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px; background: #fafafa; border-radius: 4px; }
        .cat-label { font-weight: bold; width: 55px; color: #555; }
        .cat-row input { width: 75px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
        .result { margin-left: 12px; font-weight: bold; color: #0066cc; font-size: 0.96em;}
        .calculate-btn { background: #007bff; color: white; padding: 12px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 24px auto; display: block; }
        .calculate-btn:hover { background: #0056b3; }
        #summaryResults { border-top:1px solid #ccc; padding-top:20px; margin-top:26px;}
        #summaryResults h2 { text-align:center;margin-bottom:8px;}
        #summaryResults h3 { margin-bottom:0;}
        .footer { text-align: center; margin-top: 26px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 14px; }
        
        /* Conversion Control */
        .conversion-control { 
            margin-bottom: 15px; 
            padding: 10px; 
            border: 1px solid #cceeff; 
            background: #e6f7ff; 
            border-radius: 6px; 
            display: flex; 
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        .conversion-control label {
            font-weight: bold;
            color: #0056b3;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .conversion-control input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        /* State Indicators Styles */
        .state-indicator {
          display: inline-block;
          min-width: 90px;
          font-weight: bold;
          text-align: center;
          padding: 7px 18px;
          border-radius: 7px;
          margin-right: 12px;
          font-size: 16px;
        }
        .state-standard {
          background: #e2fbe0;
          color: #208c2c;
          border: 2px solid #30ba4c;
        }
        .state-state {
          background: #ffd6d6;
          color: #be2222;
          border: 2px solid #da3131;
        }
        .state-circling {
          background: #e6f7ff;
          color: #0066cc;
          border: 2px solid #0066cc;
          display: none; /* Hidden by default */
        }

        /* Raised Minima Table Styles */
        .raised-minima-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
        }
        .raised-minima-table th, .raised-minima-table td {
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            text-align: left;
        }
        .raised-minima-table th {
            background-color: #f2f2f2;
            font-weight: bold;
            color: #333;
        }
        .raised-minima-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Minima Calculator </h1>
        <div class="top-inputs">
            <div class="input-group">
                <label>AD Elev (ft)</label>
                <input type="number" id="adElev" placeholder="0">
            </div>
            <div class="input-group">
                <label>THR Elev (ft)</label>
                <input type="number" id="thrElev" placeholder="0">
            </div>
            <div class="input-group">
                <label>ALS</label>
                <select id="lightType">
                    <option value="FALS">FALS</option>
                    <option value="IALS">IALS</option>
                    <option value="BALS">BALS</option>
                    <option value="NALS">NALS</option>
                </select>
            </div>
            <div class="procedure-group">
                <label>Procedure:</label>
                <input type="radio" name="procedure" value="CDFA" id="cdfa" checked>
                <label for="cdfa">CDFA</label>
                <input type="radio" name="procedure" value="Non-CDFA" id="noncdfa">
                <label for="noncdfa">NFC</label>
                <div id="noncdfaSubGroup" class="noncdfa-sub-group" style="display:none;">
                    <label><input type="checkbox" id="noncdfa_ab"> CAT A/B only</label>
                    <label><input type="checkbox" id="noncdfa_cd"> CAT C/D only</label>
                </div>
            </div>
        </div>

        <!-- CONTROL CHECKBOXES -->
        <div class="conversion-control">
            <label for="meterToFeetConversion">
                <input type="checkbox" id="meterToFeetConversion">
                Apply Meter to Feet Conversion Rule (DA, DH, MDA, MDH inputs interpreted as Meters)
            </label>
            <label for="showCeilingInput">
                <input type="checkbox" id="showCeilingInput">
                Show Ceiling Inputs
            </label>
        </div>

        <div class="proc-checkbox-group" id="procedureCheckboxes"></div>
        <div class="calculators" id="calculatorsArea"></div>
        <button class="calculate-btn" onclick="calculate()">Calculate All</button>
        <button class="calculate-btn" type="button" onclick="clearAllInputs()">Clear All</button>
        <div id="summaryResults"></div>
        <div class="footer">
            This tool was created by Vishal Kumar Basson, Other Contributer - Shubham Bundele (Add 'Circling Raise' & CEIL)
        </div>
    </div>

    <!-- ============ Fixed Top-Right Zoom Controls ============ -->
    <div id="page-zoom-controls" style="
      position: fixed;
      top: 18px; 
      right: 24px; 
      z-index: 2000;
      display: flex; 
      gap: 10px; 
      align-items:center;
      background: rgba(245,245,245,0.96); 
      border-radius:8px;
      padding: 8px 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    ">
      <button type="button" onclick="zoomPage('+')" title="Zoom in" style="font-size:18px;">+</button>
      <button type="button" onclick="zoomPage('-')" title="Zoom out" style="font-size:18px;">-</button>
      <span id="zoom-indicator" style="margin-left:8px;font-size:14px; color:#444;"></span>
    </div>

    <script>
        // === Define Procedures ===
        const PRECISION_PROC = [
            { code: 'cat1', name: 'CAT 1' }, { code: 'rnp', name: 'RNP' }, { code: 'gls', name: 'GLS' },
            { code: 'par', name: 'PAR' }, { code: 'lpv', name: 'LPV' }, { code: 'lnavvnav', name: 'LNAV/VNAV' }
        ];
        const NONPRECISION_PROC_250 = [
            { code: 'loc', name: 'LOC' }, { code: 'locdme', name: 'LOC+DME' }, { code: 'vordme', name: 'VOR+DME' },
            { code: 'lnav', name: 'LNAV' }, { code: 'sra', name: 'SRA' }, { code: 'lda', name: 'LDA' }
        ];
        const NONPRECISION_PROC_300 = [
            { code: 'vor', name: 'VOR' }, { code: 'ndbdme', name: 'NDB+DME' }
        ];
        const NONPRECISION_PROC_350 = [{ code: 'ndb', name: 'NDB' }];
        const CIRCLING_PROC = [{ code: 'circling', name: 'Circling' }];
        const CATS = ['A','B','C','D'];

        // Fill in all RVR ranges from your full table here!
        const RVR_TABLE_RANGES = [
            {low: 200, high: 210, FALS: 550, IALS: 750, BALS: 1000, NALS: 1200},
            {low: 211, high: 220, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
            {low: 221, high: 230, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
            {low: 231, high: 240, FALS: 550, IALS: 800, BALS: 1000, NALS: 1200},
            {low: 241, high: 250, FALS: 550, IALS: 800, BALS: 1000, NALS: 1300},
            {low: 251, high: 260, FALS: 600, IALS: 800, BALS: 1100, NALS: 1300},
            {low: 261, high: 280, FALS: 600, IALS: 900, BALS: 1100, NALS: 1300},
            {low: 281, high: 300, FALS: 650, IALS: 900, BALS: 1200, NALS: 1400},
            {low: 301, high: 320, FALS: 700, IALS: 1000, BALS: 1200, NALS: 1400},
            {low: 321, high: 340, FALS: 800, IALS: 1100, BALS: 1300, NALS: 1500},
            {low: 341, high: 360, FALS: 900, IALS: 1200, BALS: 1400, NALS: 1600},
            {low: 361, high: 380, FALS: 1000, IALS: 1300, BALS: 1500, NALS: 1700},
            {low: 381, high: 400, FALS: 1100, IALS: 1400, BALS: 1600, NALS: 1800},
            {low: 401, high: 420, FALS: 1200, IALS: 1500, BALS: 1700, NALS: 1900},
            {low: 421, high: 440, FALS: 1300, IALS: 1600, BALS: 1800, NALS: 2000},
            {low: 441, high: 460, FALS: 1400, IALS: 1700, BALS: 1900, NALS: 2100},
            {low: 461, high: 480, FALS: 1500, IALS: 1800, BALS: 2000, NALS: 2200},
            {low: 481, high: 500, FALS: 1500, IALS: 1800, BALS: 2100, NALS: 2300},
            {low: 501, high: 520, FALS: 1600, IALS: 1900, BALS: 2100, NALS: 2400},
            {low: 521, high: 540, FALS: 1700, IALS: 2000, BALS: 2200, NALS: 2400},
            {low: 541, high: 560, FALS: 1800, IALS: 2100, BALS: 2300, NALS: 2500},
            {low: 561, high: 580, FALS: 1900, IALS: 2200, BALS: 2400, NALS: 2600},
            {low: 581, high: 600, FALS: 2000, IALS: 2300, BALS: 2500, NALS: 2700},
            {low: 601, high: 620, FALS: 2100, IALS: 2400, BALS: 2600, NALS: 2800},
            {low: 621, high: 640, FALS: 2200, IALS: 2500, BALS: 2700, NALS: 2900},
            {low: 641, high: 660, FALS: 2300, IALS: 2600, BALS: 2800, NALS: 3000},
            {low: 661, high: 680, FALS: 2400, IALS: 2700, BALS: 2900, NALS: 3100},
            {low: 681, high: 700, FALS: 2500, IALS: 2800, BALS: 3000, NALS: 3200},
            {low: 701, high: 720, FALS: 2600, IALS: 2900, BALS: 3100, NALS: 3300},
            {low: 721, high: 740, FALS: 2700, IALS: 3000, BALS: 3200, NALS: 3400},
            {low: 741, high: 760, FALS: 2700, IALS: 3000, BALS: 3300, NALS: 3500},
            {low: 761, high: 800, FALS: 2900, IALS: 3200, BALS: 3400, NALS: 3600},
            {low: 801, high: 850, FALS: 3100, IALS: 3400, BALS: 3600, NALS: 3800},
            {low: 851, high: 900, FALS: 3300, IALS: 3600, BALS: 3800, NALS: 4000},
            {low: 901, high: 950, FALS: 3600, IALS: 3900, BALS: 4100, NALS: 4300},
            {low: 951, high: 1000, FALS: 3800, IALS: 4100, BALS: 4300, NALS: 4500},
            {low: 1001, high: 1100, FALS: 4100, IALS: 4400, BALS: 4600, NALS: 4900},
            {low: 1101, high: 1200, FALS: 4600, IALS: 4900, BALS: 5000, NALS: 5000},
            {low: 1201, high: 9999, FALS: 5000, IALS: 5000, BALS: 5000, NALS: 5000}
        ];
        function getRVRFromTable(dh, lightType) {
            for (let row of RVR_TABLE_RANGES) {
                if (dh >= row.low && dh <= row.high) return row[lightType];
            }
            return RVR_TABLE_RANGES[RVR_TABLE_RANGES.length-1][lightType];
        }
        function roundUpTo10(x) { return Math.ceil(x/10)*10; }

        // --- UI Generation
        function renderProcedureCheckboxes() {
            let html = "";
            PRECISION_PROC.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}" checked> ${p.name}</label>`; });
            NONPRECISION_PROC_250.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
            NONPRECISION_PROC_300.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
            NONPRECISION_PROC_350.forEach(p=>{ html += `<label><input type="checkbox" id="show_${p.code}"> ${p.name}</label>`; });
            html += '<label><input type="checkbox" id="show_circling" checked> Circling</label>';
            document.getElementById('procedureCheckboxes').innerHTML = html;
        }
        renderProcedureCheckboxes();
        function renderCalculators() {
            let html = "";
            const catRows = (proc, inputTypes) => CATS.map(cat=>{
                let fields = '';
                // Note: The conversion logic only affects the DH/DA/MDH/MDA values, not the RVR/VIS fields.
                const daType = inputTypes.includes('DA') ? 'DA':'';
                const mdaType = inputTypes.includes('MDA') ? 'MDA':'';
                const dhType = inputTypes.includes('DH') ? 'DH':'';
                const mdhType = inputTypes.includes('MDH') ? 'MDH':'';

                if(daType) fields += `<input type="number" placeholder="DA" id="${proc}_${cat}_da">`;
                if(mdaType) fields += `<input type="number" placeholder="MDA" id="${proc}_${cat}_mda">`;
                if(dhType) fields += `<input type="number" placeholder="DH" id="${proc}_${cat}_dh">`;
                if(mdhType) fields += `<input type="number" placeholder="MDH" id="${proc}_${cat}_mdh">`;
                if(inputTypes.includes('RVR'))  fields += `<input type="number" placeholder="RVR" id="${proc}_${cat}_rvr">`;
                if(inputTypes.includes('VIS'))  fields += `<input type="number" placeholder="VIS" id="${proc}_${cat}_vis" step="0.1">`;
                // Add Ceiling Input (Hidden by default)
                fields += `<input type="number" placeholder="Ceil" id="${proc}_${cat}_ceil" class="ceil-input" style="display:none;">`;
                
                return `<div class="cat-row"><div class="cat-label">CAT ${cat}</div>${fields}<div class="result" id="${proc}_${cat}_result"></div></div>`;
            }).join('');
            PRECISION_PROC.forEach(proc=>{
                html += `<div class="calculator" id="${proc.code}Calculator">
                    <h3>${proc.name}</h3>
                    ${catRows(proc.code, ['DA','DH','RVR','CEIL'])}
                </div>`;
            });
            NONPRECISION_PROC_250.forEach(proc=>{
                html += `<div class="calculator" id="${proc.code}Calculator">
                    <h3>${proc.name}</h3>
                    ${catRows(proc.code, ['MDA','MDH','RVR','CEIL'])}
                </div>`;
            });
            NONPRECISION_PROC_300.forEach(proc=>{
                html += `<div class="calculator" id="${proc.code}Calculator">
                    <h3>${proc.name}</h3>
                    ${catRows(proc.code, ['MDA','MDH','RVR','CEIL'])}
                </div>`;
            });
            NONPRECISION_PROC_350.forEach(proc=>{
                html += `<div class="calculator" id="${proc.code}Calculator">
                    <h3>${proc.name}</h3>
                    ${catRows(proc.code, ['MDA','MDH','RVR','CEIL'])}
                </div>`;
            });
            html += `<div class="calculator" id="circlingCalculator">
                <h3>Circling</h3>
                ${catRows('circling', ['MDA','MDH','VIS','CEIL'])}
            </div>`;
            document.getElementById('calculatorsArea').innerHTML = html;
        }
        renderCalculators();
        function updateCalculatorVisibility() {
            [...PRECISION_PROC, ...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350, ...CIRCLING_PROC].forEach(proc=>{
                const show = document.getElementById('show_'+proc.code)?.checked;
                document.getElementById(proc.code+'Calculator').style.display = show ? 'block':'none';
            });
        }
        document.getElementById('procedureCheckboxes').addEventListener('change', updateCalculatorVisibility);
        updateCalculatorVisibility();

        document.getElementById('noncdfa').addEventListener('change',function(){
            const s = document.getElementById('noncdfa').checked;
            document.getElementById('noncdfaSubGroup').style.display = s ? 'flex':'none';
        });
        document.getElementById('cdfa').addEventListener('change',function(){
            document.getElementById('noncdfaSubGroup').style.display = 'none';
            document.getElementById('noncdfa_ab').checked = false;
            document.getElementById('noncdfa_cd').checked = false;
        });
        
        // Toggle Ceiling Input Visibility
        document.getElementById('showCeilingInput').addEventListener('change', function(e) {
            const display = e.target.checked ? 'inline-block' : 'none';
            document.querySelectorAll('.ceil-input').forEach(el => {
                el.style.display = display;
            });
        });

        // --- MAIN LOGIC incl. ALL FEATURE/EXCEPTION RULES ---
        function calculate() {
            // NOTE: AD Elev and THR Elev are always considered FEET (no conversion)
            const adElev = parseFloat(document.getElementById('adElev').value)||0;
            const thrElev = parseFloat(document.getElementById('thrElev').value)||0;
            const lightType = document.getElementById('lightType').value;
            const useMeterConversion = document.getElementById('meterToFeetConversion').checked;

            // --- CDFA/Non-CDFA conditions ---
            const isProcCDFA = document.getElementById('cdfa').checked;
            const isNonCDFA = document.getElementById('noncdfa').checked;
            const isNonCDFA_AB = document.getElementById('noncdfa_ab').checked;
            const isNonCDFA_CD = document.getElementById('noncdfa_cd').checked;

            function isNonCDFAForCat(cat){
                if(!isNonCDFA) return false;
                if(!isNonCDFA_AB && !isNonCDFA_CD) return true;
                if(isNonCDFA_AB && isNonCDFA_CD) return true;
                if(isNonCDFA_AB && ['A','B'].includes(cat)) return true;
                if(isNonCDFA_CD && ['C','D'].includes(cat)) return true;
                return false;
            }

            // --- HELPER: Meter to Feet Conversion Rule ---
            // Input value (Meters) * 3.28084, then Round Up to integer (Feet)
            function toFeet(rawValue) {
                if (!rawValue && rawValue !== 0) return 0; // handle NaN/null/undefined
                if (rawValue === 0) return 0;
                // Only convert if the checkbox is ticked
                if (useMeterConversion) {
                    // Rule: input value * 3.28084 then ROUNDUP(val, 0)
                    return Math.ceil(rawValue * 3.28084);
                }
                // Otherwise, treat the raw value as feet
                return rawValue;
            }
            
            // =======================================================
            // 1. CALCULATE STANDARD CIRCLING BASELINE (PRIORITY 1)
            // =======================================================
            let summary = {};
            summary.circling = {};
            
            const catMins = {A:400,B:500,C:600,D:700};
            const visDefaults = {A:1.5,B:1.6,C:2.4,D:3.6};
            
            // Store Standard Circling Values specifically for comparison
            // structure: { A: { mdh:..., vis:... }, ... }
            let stdCirclingValues = { A:{}, B:{}, C:{}, D:{} };

            CATS.forEach(cat=>{
                // Grab raw input for Circling
                let mdaRaw = 0, mdhRaw = 0, vis = 0;
                let ceilRaw = 0;
                // We always calculate standard circling even if hidden, to serve as baseline
                if(document.getElementById('circlingCalculator')) {
                   mdaRaw = parseFloat(document.getElementById(`circling_${cat}_mda`).value)||0;
                   mdhRaw = parseFloat(document.getElementById(`circling_${cat}_mdh`).value)||0;
                   vis = parseFloat(document.getElementById(`circling_${cat}_vis`).value)||0; 
                   ceilRaw = parseFloat(document.getElementById(`circling_${cat}_ceil`).value)||0;
                }
                
                const mda = toFeet(mdaRaw);
                const mdh = toFeet(mdhRaw);
                
                const mdhUsed = Math.max(mdh, catMins[cat]);
                const mdaCalc = roundUpTo10(adElev+mdhUsed);
                // Ensure mda input is rounded if it exceeds calculated
                const mdaFinal = roundUpTo10(Math.max(mda, mdaCalc));
                const visFinal = Math.max(vis||0, visDefaults[cat]);
                
                // Handle Ceiling Logic: Show ONLY if Ceiling > MDH (mdhUsed)
                let ceil = toFeet(ceilRaw);
                if(ceil > 0) ceil = Math.ceil(ceil/100)*100;
                const ceilStr = (ceil > mdhUsed) ? ` [CEIL] ${ceil}ft` : '';

                // Save baseline
                stdCirclingValues[cat] = {
                    mdh: mdhUsed,
                    mda: mdaFinal, // Also store MDA for Altitude comparison
                    vis: visFinal
                };

                const res = `MDA: ${mdaFinal}(${mdhUsed}), VIS: ${visFinal}km${ceilStr}`;
                // Only add to summary if checkbox enabled
                if(document.getElementById('show_circling').checked) {
                   document.getElementById(`circling_${cat}_result`).innerText = mdaRaw||mdhRaw||vis||ceilRaw ? res:"";
                   summary.circling[cat] = mdaRaw||mdhRaw||vis||ceilRaw ? res:"";
                }
            });

            // =======================================================
            // 2. LOOP PROCEDURES: CALC STRAIGHT-IN & COMPARE
            // =======================================================
            
            let circlingAtResults = [];
            let circlingLowerFound = false; // Flag for Blue Label

            // Helper to add a Circling @ result
            function checkAndAddCirclingAt(procName, cat, si_mdh_check, si_vis_km) {
                const std = stdCirclingValues[cat];
                
                // Compare: If Straight-In MDH > Standard Circling MDH OR Straight-In Vis > Standard Circling Vis
                if (si_mdh_check > std.mdh || si_vis_km > std.vis) {
                    
                    // Apply Circling Rules: Use Higher Value
                    const newMDH = Math.max(si_mdh_check, std.mdh);
                    const newVis = Math.max(si_vis_km, std.vis);
                    
                    // Calc new MDA based on AD Elev (Circling Rule)
                    const newMDA = roundUpTo10(adElev + newMDH);
                    
                    // Format Result
                    const resStr = `MDA: ${newMDA}(${newMDH}), VIS: ${newVis}km`;
                    
                    circlingAtResults.push({
                        label: `Circling @ ${procName}`,
                        cat: cat,
                        val: resStr
                    });
                }
            }

            // --- PRECISION Approaches ---
            PRECISION_PROC.forEach(proc=>{
                if(!document.getElementById('show_'+proc.code).checked) return;
                summary[proc.code] = {};
                CATS.forEach(cat=>{
                    const daRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_da`).value)||0;
                    const dhRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_dh`).value)||0;
                    const da = toFeet(daRaw);
                    const dh = toFeet(dhRaw);
                    const ceilRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_ceil`).value)||0;
                    
                    // --- NEW RVR/VIS DETECTION LOGIC ---
                    const rvrRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_rvr`).value)||0;
                    let rvr = rvrRaw;
                    let isVisInput = false;
                    // If input is small (e.g. < 10), assume it's KM Vis, convert to Meters for calc
                    if(rvrRaw > 0 && rvrRaw < 20) {
                        rvr = rvrRaw * 1000;
                        isVisInput = true;
                    }

                    const dhRaised = (proc.code === "lnavvnav") ? Math.max(dh, 250) : Math.max(dh, 200);
                    const daCalc = thrElev + dhRaised;
                    const daFinal = Math.max(da, daCalc);
                    const rvrTable = getRVRFromTable(dhRaised,lightType);
                    
                    let rvrFinal;
                    if(!isNonCDFAForCat(cat)) {
                        // CDFA / Precision Logic with Cap
                        
                        // --- NEW PRECISION OVERRIDE LOGIC ---
                        if (rvr > 2400) {
                            // If Entered Value (converted to meters) > 2400m, directly use entered value.
                            rvrFinal = rvr;
                        } else {
                            // Otherwise, standard logic with 2400m Cap on Table Value
                            // Standard Capped = min(RawTable, 2400)
                            const standardCapped = Math.min(rvrTable, 2400);
                            // Final = max(StandardCapped, UserInput)
                            rvrFinal = Math.max(standardCapped, rvr);
                        }
                    } else {
                         // Fallback for Non-CDFA on precision (rare)
                         rvrFinal = Math.max(rvrTable, rvr);
                    }

                    // ** CHECK FOR BLUE CIRCLING LABEL **
                    if (daFinal > stdCirclingValues[cat].mda) {
                        circlingLowerFound = true;
                    }
                    
                    // Handle Ceiling: Show ONLY if Ceiling > DH (dhRaised)
                    let ceil = toFeet(ceilRaw);
                    if(ceil > 0) ceil = Math.ceil(ceil/100)*100;
                    const ceilStr = (ceil > dhRaised) ? ` [CEIL] ${ceil}ft` : '';

                    // Format Result String based on input type
                    let visStr = '';
                    if(isVisInput) {
                        // Convert back to KM for display
                        visStr = `VIS: ${(rvrFinal/1000).toFixed(1)}km`; // Keep 1 decimal usually sufficient for VIS
                        // If original was 1.5, and we used it, it shows 1.5. 
                        // If original was 1.5 (1500) and floor was 2400, it shows 2.4km.
                    } else {
                        visStr = `RVR: ${rvrFinal}m`;
                    }

                    const res = `DA: ${daFinal}(${dhRaised}), ${visStr}${ceilStr}`;
                    document.getElementById(`${proc.code}_${cat}_result`).innerText = daRaw||dhRaw||rvrRaw||ceilRaw ? res : '';
                    summary[proc.code][cat] = daRaw||dhRaw||rvrRaw||ceilRaw ? res : '';

                    // ** NEW: Check for Circling @ **
                    if (daRaw||dhRaw||rvrRaw) {
                        checkAndAddCirclingAt(proc.name, cat, dhRaised, rvrFinal/1000);
                    }
                });
            });

            // --- NONPRECISION Approaches ---
            [...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350].forEach(proc=>{
                if(!document.getElementById('show_'+proc.code).checked) return;
                summary[proc.code] = {};
                let minMDH = 250;
                if(NONPRECISION_PROC_300.some(p=>p.code===proc.code)) minMDH=300;
                if(NONPRECISION_PROC_350.some(p=>p.code===proc.code)) minMDH=350;
                CATS.forEach(cat=>{
                    const mdaRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_mda`).value)||0;
                    const mdhRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_mdh`).value)||0;
                    const ceilRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_ceil`).value)||0;
                    
                    const mda = toFeet(mdaRaw);
                    const mdh = toFeet(mdhRaw);
                    
                    // --- NEW RVR/VIS DETECTION LOGIC ---
                    const rvrRaw = parseFloat(document.getElementById(`${proc.code}_${cat}_rvr`).value)||0;
                    let rvr = rvrRaw;
                    let isVisInput = false;
                    if(rvrRaw > 0 && rvrRaw < 20) {
                        rvr = rvrRaw * 1000;
                        isVisInput = true;
                    }
                    
                    let mdhUsed = mdh;
                    let calcMDA = mda;
                    
                    if(mdh>0 && mdh<minMDH) {
                        mdhUsed = minMDH;
                        calcMDA = roundUpTo10(thrElev + mdhUsed);
                        if(mda>calcMDA) calcMDA = mda;
                    } else if(mdh>=minMDH) {
                        calcMDA = mda;
                        // If mda input was empty/zero, but mdh is provided, calculate MDA
                        if (calcMDA === 0) calcMDA = thrElev + mdhUsed;
                    } else if (mdh === 0) {
                        if (mda > 0) {
                            calcMDA = mda;
                            mdhUsed = mda - thrElev;
                        } else {
                            mdhUsed = minMDH;
                            calcMDA = roundUpTo10(thrElev + mdhUsed);
                        }
                    }
                    // Always round Non-Precision MDA to next 10
                    if(calcMDA > 0) calcMDA = roundUpTo10(calcMDA);

                    let rvrFinal;
                    // --- New rule: If MDH > 1200 => always Non-CDFA, RVR = 5000m
                    if(mdhUsed > 1200) {
                        rvrFinal = 5000;
                        
                        // Handle Ceiling: Show ONLY if Ceiling > MDH (mdhUsed)
                        let ceil = toFeet(ceilRaw);
                        if(ceil > 0) ceil = Math.ceil(ceil/100)*100;
                        const ceilStr = (ceil > mdhUsed) ? ` [CEIL] ${ceil}ft` : '';
                        
                        const res = `MDA: ${calcMDA}(${mdhUsed}), RVR: 5000m (forced Non-CDFA: MDH > 1200)${ceilStr}`;
                        document.getElementById(`${proc.code}_${cat}_result`).innerText = res;
                        summary[proc.code][cat] = res;
                        // Still check for Circling @ with forced values
                        checkAndAddCirclingAt(proc.name, cat, mdhUsed, 5.0);
                        // Also check label logic
                        if (calcMDA > stdCirclingValues[cat].mda) circlingLowerFound = true;
                        return; 
                    }

                    const rvrTable = getRVRFromTable(mdhUsed||minMDH, lightType);
                    
                    if(!isNonCDFAForCat(cat)) { 
                        // CDFA
                        const base = Math.max(750, rvrTable);
                        const maxRVR = ['A','B'].includes(cat) ? 1500 : 2400;
                        // Floor is Standard Capped
                        const floor = Math.min(base, maxRVR);
                        rvrFinal = Math.max(floor, rvr);
                    } else { 
                        // Non-CDFA
                        let minRVR = ['A','B'].includes(cat)?1000:1200;
                        rvrFinal = Math.max(minRVR, rvrTable, rvr);
                    }
                    
                    // ** CHECK FOR BLUE CIRCLING LABEL **
                    if (calcMDA > stdCirclingValues[cat].mda) {
                        circlingLowerFound = true;
                    }
                    
                    // Handle Ceiling: Show ONLY if Ceiling > MDH (mdhUsed)
                    let ceil = toFeet(ceilRaw);
                    if(ceil > 0) ceil = Math.ceil(ceil/100)*100;
                    const ceilStr = (ceil > mdhUsed) ? ` [CEIL] ${ceil}ft` : '';

                    // Format Result String
                    let visStr = '';
                    if(isVisInput) {
                        visStr = `VIS: ${(rvrFinal/1000).toFixed(1)}km`;
                    } else {
                        visStr = `RVR: ${rvrFinal}m`;
                    }

                    const res = `MDA: ${calcMDA}(${mdhUsed}), ${visStr}${ceilStr}`;
                    document.getElementById(`${proc.code}_${cat}_result`).innerText = mdaRaw||mdhRaw||rvrRaw||ceilRaw?res:"";
                    summary[proc.code][cat] = mdaRaw||mdhRaw||rvrRaw||ceilRaw?res:"";
                    
                    // ** NEW: Check for Circling @ **
                    if (mdaRaw||mdhRaw||rvrRaw) {
                        checkAndAddCirclingAt(proc.name, cat, mdhUsed, rvrFinal/1000);
                    }
                });
            });

            // Store the list and flag for rendering
            summary.circlingAtList = circlingAtResults;
            summary.circlingLowerFound = circlingLowerFound;
            updateSummaryResults(summary);
        }
        
        document.addEventListener('input',function(e){ 
            if(e.target.type==='number' || e.target.id === 'meterToFeetConversion') calculate(); 
        });
        document.addEventListener('change',function(e){
            if(['radio','checkbox','select-one'].includes(e.target.type)) {
                updateCalculatorVisibility();
                calculate();
            }
        });
        
        function clearAllInputs() {
            // Clear all numbers and text
            document.querySelectorAll('input[type="number"], input[type="text"]').forEach(el => el.value = '');

            // Reset all result blocks
            document.querySelectorAll('.result').forEach(el => el.innerText = '');
            document.getElementById('summaryResults').innerHTML = '';

            // Reset radio buttons: Default to CDFA
            document.getElementById('cdfa').checked = true;
            document.getElementById('noncdfa').checked = false;
            // Hide Non CDFA subgroup, uncheck suboptions
            document.getElementById('noncdfaSubGroup').style.display = 'none';
            document.getElementById('noncdfa_ab').checked = false;
            document.getElementById('noncdfa_cd').checked = false;
            
            // Reset conversion checkbox (new addition)
            document.getElementById('meterToFeetConversion').checked = false;
            
            // Reset Show Ceiling checkbox and hide inputs
            document.getElementById('showCeilingInput').checked = false;
            document.querySelectorAll('.ceil-input').forEach(el => el.style.display = 'none');


            // Set calculator checkboxes: default is all precision checked, circling checked, others unchecked
            // (Reverting to default script state)
            [...PRECISION_PROC, ...CIRCLING_PROC].forEach(proc => {
                let el = document.getElementById('show_'+proc.code);
                if(el) el.checked = true;
            });
            [...NONPRECISION_PROC_250, ...NONPRECISION_PROC_300, ...NONPRECISION_PROC_350].forEach(proc => {
                let el = document.getElementById('show_'+proc.code);
                if(el) el.checked = false;
            });
            updateCalculatorVisibility();

            // Optional: scroll to top, focus the first input, or reset selects if you want
            window.scrollTo(0,0);
        }
        // ---- Top-right Page Zoom Controls ----
        let zoomLevel = 1;
        const minZoom = 0.7;
        const maxZoom = 2;

        function zoomPage(direction) {
            if(direction === '+') {
                zoomLevel = Math.min(maxZoom, zoomLevel + 0.1);
            } else if(direction === '-') {
                zoomLevel = Math.max(minZoom, zoomLevel - 0.1);
            }
            document.body.style.zoom = zoomLevel;
            document.getElementById('zoom-indicator').innerText = `Zoom: ${(zoomLevel*100).toFixed(0)}%`;
        }

        window.addEventListener('DOMContentLoaded',()=>{
            document.body.style.zoom = zoomLevel;
            document.getElementById('zoom-indicator').innerText = `Zoom: ${(zoomLevel*100).toFixed(0)}%`;
            calculate(); // Run initial calculation on load
        });
        
        // Advanced Summary Results with State logic
        function updateSummaryResults(results) {
            const useMeterConversion = document.getElementById('meterToFeetConversion').checked;
            const circlingIsLower = results.circlingLowerFound; // Get flag from calculate()

            // Helper function to get the actual feet value for comparison, taking conversion into account
            function getFeetValueForCheck(rawValue, applyConversion) {
                 if (!rawValue && rawValue !== 0) return 0;
                 if (applyConversion) {
                    return Math.ceil(rawValue * 3.28084);
                 }
                 return rawValue;
            }

            let anyState = false;
            const blocks = [
                ...PRECISION_PROC,
                ...NONPRECISION_PROC_250,
                ...NONPRECISION_PROC_300,
                ...NONPRECISION_PROC_350,
                ...CIRCLING_PROC
            ].filter(proc => document.getElementById('show_'+proc.code)?.checked);
            
            function isStateValue(proc, cat, value) {
                let regulatoryMin = null;

                // Grab raw input (which is what the user would have entered)
                const dhRaw = parseFloat(document.getElementById(`${proc}_${cat}_dh`)?.value)||0;
                const mdhRaw = parseFloat(document.getElementById(`${proc}_${cat}_mdh`)?.value)||0;
                const rvrVisRaw = parseFloat(document.getElementById(`${proc}_${cat}_rvr`)?.value)||parseFloat(document.getElementById(`${proc}_${cat}_vis`)?.value)||0;

                // Determine if DA/DH/MDA/MDH was converted for this specific check
                const dhCheck = getFeetValueForCheck(dhRaw, useMeterConversion);
                const mdhCheck = getFeetValueForCheck(mdhRaw, useMeterConversion);
                
                if (PRECISION_PROC.some(p=>p.code===proc)) {
                    let dhRaised;
                    if(proc === "lnavvnav") {
                        dhRaised = Math.max(dhCheck, 250);
                    } else {
                        dhRaised = Math.max(dhCheck, 200);
                    }
                    const tableVal = getRVRFromTable(dhRaised, document.getElementById('lightType').value);
                    // Precision Cap Logic for State Check: Standard = min(table, 2400)
                    // We use 2400 for all here because user asked for general override > 2400.
                    // But strictly speaking, standard cap is 1500/2400. 
                    // Let's assume State Logic follows the general override rule:
                    // If entered > 2400, it is State (because standard is capped at 2400 max).
                    const cap = 2400; 
                    regulatoryMin = Math.min(tableVal, cap);

                } else if (CIRCLING_PROC.some(p=>p.code===proc)) {
                    regulatoryMin = {A:1.5,B:1.6,C:2.4,D:3.6}[cat];
                } else { // Non-Precision
                    let minMDH = 250;
                    if(NONPRECISION_PROC_300.some(p=>p.code===proc)) minMDH=300;
                    if(NONPRECISION_PROC_350.some(p=>p.code===proc)) minMDH=350;
                    let mdhUsed = mdhCheck > 0 ? Math.max(mdhCheck, minMDH) : minMDH;
                    if(mdhUsed > 1200) return value >= 5000;
                    
                    const isNonCDFA = document.getElementById('noncdfa').checked;
                    const isNonCDFA_AB = document.getElementById('noncdfa_ab').checked;
                    const isNonCDFA_CD = document.getElementById('noncdfa_cd').checked;
                    function isNonCDFAForCat(cat){
                        if(!isNonCDFA) return false;
                        if(!isNonCDFA_AB && !isNonCDFA_CD) return true;
                        if(isNonCDFA_AB && isNonCDFA_CD) return true;
                        if(isNonCDFA_AB && ['A','B'].includes(cat)) return true;
                        if(isNonCDFA_CD && ['C','D'].includes(cat)) return true;
                        return false;
                    }

                    const rvrTable = getRVRFromTable(mdhUsed, document.getElementById('lightType').value);
                    let base;
                    if(!isNonCDFAForCat(cat)) {
                        base = Math.max(750, rvrTable);
                    } else {
                        base = Math.max(['A','B'].includes(cat)?1000:1200, rvrTable);
                    }
                    // Non-Precision Cap Logic for State Check
                    const cap = ['A','B'].includes(cat) ? 1500 : 2400;
                    regulatoryMin = Math.min(base, cap);
                }
                
                if(rvrVisRaw == 0) return false;
                
                // Check if value is Vis (small number) or RVR
                // The value passed in `value` here comes from parsing the result string in the loop below
                // But wait, `rvrVisRaw` is the RAW input. 
                // If `rvrVisRaw` < 20, it's Vis KM. Multiply by 1000 for comparison against regulatoryMin (Meters).
                // If `regulatoryMin` is small (Circling Vis KM), comparing against raw is correct.
                
                let compVal = rvrVisRaw;
                if(CIRCLING_PROC.some(p=>p.code===proc)) {
                    // Circling compares KM vs KM
                    return rvrVisRaw > regulatoryMin;
                } else {
                    // Straight-in compares Meters vs Meters
                    if(rvrVisRaw < 20) compVal = rvrVisRaw * 1000;
                    return compVal > regulatoryMin;
                }
            }
            
            let html = `<div style="display:flex;gap:14px;align-items:center;margin-bottom:12px;">`;
            html += `<span class="state-indicator state-standard" id="summaryStandardBox">STANDARD</span>`;
            html += `<span class="state-indicator" id="summaryStateBox">STATE</span>`;
            html += `<span class="state-indicator state-circling" id="summaryCirclingBox">CIRCLING</span>`;
            html += `</div>`;
            html += `<h2>Summary of Results</h2>`;
            blocks.forEach(proc=>{
                if(!results[proc.code])return;
                html += `<div style="margin-bottom:14px;"><h3>${proc.name}</h3>`;
                CATS.forEach(cat=>{
                    const resultText = results[proc.code][cat] || '';
                    let highlight = '';
                    if(resultText) {
                        let m = /RVR:\s*(\d+(?:\.\d+)?)m/i.exec(resultText);
                        if(!m) m = /VIS:\s*(\d+(?:\.\d+)?)/i.exec(resultText);
                        if(m) {
                            // m[1] is the numeric part of the result string (already processed/maxed)
                            // State check essentially needs to know if the USER input triggered a higher state.
                            // isStateValue uses DOM input to decide.
                            if(isStateValue(proc.code,cat, parseFloat(m[1]))) {
                                highlight = "color:#be2222;font-weight:bold;";
                                anyState = true;
                            }
                        }
                    }
                    html += `<div>CAT ${cat}: <span style="${highlight}">${resultText}</span></div>`;
                });
                html += `</div>`;
            });
            
            // --- Render "Circling @" table if entries exist ---
            if (results.circlingAtList && results.circlingAtList.length > 0) {
                html += `<div style="margin-top:20px;">`;
                html += `<h3>Circling @ (Raised Minima)</h3>`;
                
                html += `<table class="raised-minima-table">`;
                html += `<thead><tr><th>Procedure</th><th>CAT</th><th>Minima</th><th>Visibility</th></tr></thead>`;
                html += `<tbody>`;
                
                results.circlingAtList.forEach(item => {
                    const procedureName = item.label.replace('Circling @ ', '');
                    const catName = `CAT ${item.cat}`;
                    
                    // Split safe: "MDA: 1200(1200), VIS: 5km"
                    const parts = item.val.split(', ');
                    const minima = parts[0] || item.val;
                    const visibility = parts[1] || '';

                    html += `<tr>`;
                    html += `<td>${procedureName}</td>`;
                    html += `<td>${catName}</td>`;
                    html += `<td>${minima}</td>`;
                    html += `<td>${visibility}</td>`;
                    html += `</tr>`;
                });
                
                html += `</tbody></table></div>`;
            }

            document.getElementById('summaryResults').innerHTML = html;
            document.getElementById('summaryStandardBox').className = 'state-indicator'+(anyState?'':' state-standard');
            document.getElementById('summaryStateBox').className = 'state-indicator'+(anyState?' state-state':'');
            
            const circBox = document.getElementById('summaryCirclingBox');
            if(circBox) {
                circBox.style.display = circlingIsLower ? 'inline-block' : 'none';
            }
        }
        // ==== AUTOCHECK: Select Only Circling By Default ====
        window.addEventListener('DOMContentLoaded', function() {
            // Uncheck all main procedure checkboxes (precision, non-precision)
            [
                ...PRECISION_PROC,
                ...NONPRECISION_PROC_250,
                ...NONPRECISION_PROC_300,
                ...NONPRECISION_PROC_350
            ].forEach(proc=>{
                var el = document.getElementById('show_'+proc.code);
                if(el) el.checked = false;
            });
            // Check only "Circling"
            var circ = document.getElementById('show_circling');
            if(circ) circ.checked = true;
            // Update the UI accordingly
            if (typeof updateCalculatorVisibility === 'function') updateCalculatorVisibility();
        });
    </script>
</body>
</html>
